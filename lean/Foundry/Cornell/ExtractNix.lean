/-
  Cornell.ExtractNix - C++ Code Generation for Nix Formats
  
  Generates nix_formats.h from the Lean specifications in Foundry.Cornell.Nix, Cornell.Nar,
  Cornell.NarInfo, and Cornell.Drv.
  
  ## Generated Code
  
  - NAR parser/serializer (streaming compatible)
  - NarInfo parser/serializer (text format)
  - Derivation (.drv) parser/serializer (ATerm format)
  - Wire primitives (NixString, StorePath, etc.)
  
  ## Design
  
  The generated C++ code mirrors the Lean specification exactly.
  Reset-on-ambiguity semantics are preserved in all parsers.
-/

import Foundry.Cornell.Nix

namespace Cornell.ExtractNix

-- ═══════════════════════════════════════════════════════════════════════════════
-- FILE HEADER
-- ═══════════════════════════════════════════════════════════════════════════════

def genHeader : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// GENERATED BY CORNELL - DO NOT EDIT
// Source: Cornell.ExtractNix (from Foundry.Cornell.Nix, Cornell.Nar, Cornell.NarInfo, Cornell.Drv)
//
// This file is extracted from verified Lean specifications.
// NAR determinism and format correctness are proven in Lean.
//
// To regenerate:
//   lake build && lake exe cornell_nix_gen > path/to/nix_formats.h
// ═══════════════════════════════════════════════════════════════════════════════

#pragma once

#include <array>
#include <cstdint>
#include <optional>
#include <span>
#include <string>
#include <string_view>
#include <variant>
#include <vector>

namespace cornell::nix {
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- WIRE PRIMITIVES
-- ═══════════════════════════════════════════════════════════════════════════════

def genWirePrimitives : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// Wire Primitives
// Generated from: Foundry.Cornell.Nix (NixString, padSize, etc.)
// ═══════════════════════════════════════════════════════════════════════════════

/// Calculate padding to 8-byte boundary
/// Lean: def padSize (len : Nat) : Nat := let rem := len % 8; if rem == 0 then 0 else 8 - rem
[[nodiscard]] constexpr auto pad_size(std::size_t len) noexcept -> std::size_t {
  const auto rem = len % 8;
  return rem == 0 ? 0 : 8 - rem;
}

/// Parse result with three outcomes
template<typename T>
struct parse_result_t {
  std::optional<T> value;
  std::span<const std::uint8_t> remaining;
  std::optional<std::string> error;
  
  [[nodiscard]] auto is_ok() const noexcept -> bool { return value.has_value() && !error.has_value(); }
  [[nodiscard]] auto is_incomplete() const noexcept -> bool { return !value.has_value() && !error.has_value(); }
  [[nodiscard]] auto is_error() const noexcept -> bool { return error.has_value(); }
  
  static auto ok(T v, std::span<const std::uint8_t> rest) -> parse_result_t {
    return {std::move(v), rest, std::nullopt};
  }
  
  static auto incomplete(std::span<const std::uint8_t> rest) -> parse_result_t {
    return {std::nullopt, rest, std::nullopt};
  }
  
  static auto fail(std::string err) -> parse_result_t {
    return {std::nullopt, {}, std::move(err)};
  }
};

/// Parse u64 little-endian
/// Lean: def parseU64Strict
[[nodiscard]] inline auto parse_u64le(std::span<const std::uint8_t> bs) 
    -> parse_result_t<std::uint64_t> {
  if (bs.size() < 8) {
    return parse_result_t<std::uint64_t>::incomplete(bs);
  }
  const std::uint64_t value = 
      static_cast<std::uint64_t>(bs[0])
    | (static_cast<std::uint64_t>(bs[1]) << 8)
    | (static_cast<std::uint64_t>(bs[2]) << 16)
    | (static_cast<std::uint64_t>(bs[3]) << 24)
    | (static_cast<std::uint64_t>(bs[4]) << 32)
    | (static_cast<std::uint64_t>(bs[5]) << 40)
    | (static_cast<std::uint64_t>(bs[6]) << 48)
    | (static_cast<std::uint64_t>(bs[7]) << 56);
  return parse_result_t<std::uint64_t>::ok(value, bs.subspan(8));
}

/// Serialize u64 little-endian
inline auto serialize_u64le(std::uint64_t value, std::vector<std::uint8_t>& out) -> void {
  out.push_back(static_cast<std::uint8_t>(value & 0xFF));
  out.push_back(static_cast<std::uint8_t>((value >> 8) & 0xFF));
  out.push_back(static_cast<std::uint8_t>((value >> 16) & 0xFF));
  out.push_back(static_cast<std::uint8_t>((value >> 24) & 0xFF));
  out.push_back(static_cast<std::uint8_t>((value >> 32) & 0xFF));
  out.push_back(static_cast<std::uint8_t>((value >> 40) & 0xFF));
  out.push_back(static_cast<std::uint8_t>((value >> 48) & 0xFF));
  out.push_back(static_cast<std::uint8_t>((value >> 56) & 0xFF));
}

/// Parse Nix string (length-prefixed + padded)
/// Lean: def parseNixString
[[nodiscard]] inline auto parse_nix_string(std::span<const std::uint8_t> bs) 
    -> parse_result_t<std::string> {
  auto len_result = parse_u64le(bs);
  if (!len_result.is_ok()) {
    return parse_result_t<std::string>::incomplete(bs);
  }
  
  const auto len = static_cast<std::size_t>(len_result.value.value());
  const auto pad_len = pad_size(len);
  const auto total_len = len + pad_len;
  
  if (len_result.remaining.size() < total_len) {
    return parse_result_t<std::string>::incomplete(bs);
  }
  
  std::string data(reinterpret_cast<const char*>(len_result.remaining.data()), len);
  return parse_result_t<std::string>::ok(std::move(data), len_result.remaining.subspan(total_len));
}

/// Serialize Nix string
/// Lean: def serializeNixString
inline auto serialize_nix_string(std::string_view s, std::vector<std::uint8_t>& out) -> void {
  serialize_u64le(s.size(), out);
  out.insert(out.end(), s.begin(), s.end());
  const auto pad_len = pad_size(s.size());
  for (std::size_t i = 0; i < pad_len; ++i) {
    out.push_back(0);
  }
}
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- NAR FORMAT
-- ═══════════════════════════════════════════════════════════════════════════════

def genNarFormat : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// NAR (Nix ARchive) Format
// Generated from: Cornell.Nar
// ═══════════════════════════════════════════════════════════════════════════════

/// NAR magic string
/// Lean: def NAR_MAGIC : String := \"nix-archive-1\"
inline constexpr std::string_view nar_magic = \"nix-archive-1\";

/// NAR node type
/// Lean: inductive NarNodeType
enum class nar_node_type_t : std::uint8_t {
  regular,
  directory,
  symlink,
};

/// NAR error reasons
/// Lean: inductive NarError
enum class nar_error_t : std::uint8_t {
  invalid_magic,
  invalid_node_type,
  unexpected_token,
  truncated,
  name_too_large,
  contents_too_large,
  unsorted_entry,
  duplicate_entry,
  recursion_too_deep,
};

/// Maximum recursion depth
/// Lean: def maxNarDepth : Nat := 256
inline constexpr std::size_t max_nar_depth = 256;

/// Maximum entry name length  
/// Lean: def maxEntryNameLen : Nat := 4096
inline constexpr std::size_t max_entry_name_len = 4096;

/// Maximum file size (1 GB)
/// Lean: def maxFileSize : Nat := 1024 * 1024 * 1024
inline constexpr std::size_t max_file_size = 1024ULL * 1024 * 1024;

/// Forward declarations
struct nar_node_t;
struct nar_entry_t;

/// NAR directory entry
/// Lean: structure NarEntry
struct nar_entry_t {
  std::string name;
  std::unique_ptr<nar_node_t> node;
};

/// NAR node (discriminated union)
/// Lean: inductive NarNode
struct nar_node_t {
  struct file_t {
    bool executable;
    std::vector<std::uint8_t> contents;
  };
  
  struct dir_t {
    std::vector<nar_entry_t> entries;  // Must be sorted by name
  };
  
  struct symlink_t {
    std::string target;
  };
  
  std::variant<file_t, dir_t, symlink_t> data;
  
  [[nodiscard]] auto is_file() const noexcept -> bool { 
    return std::holds_alternative<file_t>(data); 
  }
  [[nodiscard]] auto is_dir() const noexcept -> bool { 
    return std::holds_alternative<dir_t>(data); 
  }
  [[nodiscard]] auto is_symlink() const noexcept -> bool { 
    return std::holds_alternative<symlink_t>(data); 
  }
};

/// NAR archive
/// Lean: structure Nar
struct nar_t {
  nar_node_t root;
};

/// Serialize NAR node to bytes
/// Lean: partial def serializeNarNode
auto serialize_nar_node(const nar_node_t& node, std::vector<std::uint8_t>& out) -> void;

/// Serialize complete NAR archive
/// Lean: def serializeNar
inline auto serialize_nar(const nar_t& nar, std::vector<std::uint8_t>& out) -> void {
  serialize_nix_string(nar_magic, out);
  serialize_nar_node(nar.root, out);
}

inline auto serialize_nar_node(const nar_node_t& node, std::vector<std::uint8_t>& out) -> void {
  serialize_nix_string(\"(\", out);
  serialize_nix_string(\"type\", out);
  
  if (node.is_file()) {
    const auto& file = std::get<nar_node_t::file_t>(node.data);
    serialize_nix_string(\"regular\", out);
    
    if (file.executable) {
      serialize_nix_string(\"executable\", out);
      serialize_nix_string(\"\", out);
    }
    
    serialize_nix_string(\"contents\", out);
    serialize_u64le(file.contents.size(), out);
    out.insert(out.end(), file.contents.begin(), file.contents.end());
    const auto pad_len = pad_size(file.contents.size());
    for (std::size_t i = 0; i < pad_len; ++i) {
      out.push_back(0);
    }
  } else if (node.is_dir()) {
    const auto& dir = std::get<nar_node_t::dir_t>(node.data);
    serialize_nix_string(\"directory\", out);
    
    for (const auto& entry : dir.entries) {
      serialize_nix_string(\"entry\", out);
      serialize_nix_string(\"(\", out);
      serialize_nix_string(\"name\", out);
      serialize_nix_string(entry.name, out);
      serialize_nix_string(\"node\", out);
      serialize_nar_node(*entry.node, out);
      serialize_nix_string(\")\", out);
    }
  } else {
    const auto& link = std::get<nar_node_t::symlink_t>(node.data);
    serialize_nix_string(\"symlink\", out);
    serialize_nix_string(\"target\", out);
    serialize_nix_string(link.target, out);
  }
  
  serialize_nix_string(\")\", out);
}

/// Parse NAR archive (streaming compatible)
[[nodiscard]] auto parse_nar(std::span<const std::uint8_t> bs) -> parse_result_t<nar_t>;
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- NARINFO FORMAT
-- ═══════════════════════════════════════════════════════════════════════════════

def genNarInfoFormat : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// NarInfo Format (Binary Cache Metadata)
// Generated from: Cornell.NarInfo
// ═══════════════════════════════════════════════════════════════════════════════

/// Compression algorithm
/// Lean: inductive Compression
enum class compression_t : std::uint8_t {
  none,
  xz,
  bzip2,
  zstd,
  lzip,
  lz4,
  br,
};

[[nodiscard]] inline auto compression_from_string(std::string_view s) -> std::optional<compression_t> {
  if (s == \"none\") return compression_t::none;
  if (s == \"xz\") return compression_t::xz;
  if (s == \"bzip2\") return compression_t::bzip2;
  if (s == \"zstd\") return compression_t::zstd;
  if (s == \"lzip\") return compression_t::lzip;
  if (s == \"lz4\") return compression_t::lz4;
  if (s == \"br\") return compression_t::br;
  return std::nullopt;
}

[[nodiscard]] inline auto compression_to_string(compression_t c) -> std::string_view {
  switch (c) {
    case compression_t::none: return \"none\";
    case compression_t::xz: return \"xz\";
    case compression_t::bzip2: return \"bzip2\";
    case compression_t::zstd: return \"zstd\";
    case compression_t::lzip: return \"lzip\";
    case compression_t::lz4: return \"lz4\";
    case compression_t::br: return \"br\";
  }
  return \"none\";
}

/// Signature
/// Lean: structure Sig
struct sig_t {
  std::string key_name;
  std::string sig;  // base64-encoded Ed25519 signature
};

/// NarInfo data
/// Lean: structure NarInfoData
struct narinfo_t {
  std::string store_path;
  std::string url;
  compression_t compression;
  std::size_t file_size;
  std::optional<std::string> file_hash;
  std::size_t nar_size;
  std::string nar_hash;
  std::vector<std::string> references;
  std::optional<std::string> deriver;
  std::vector<sig_t> sigs;
  std::optional<std::string> ca;
};

/// NarInfo parse error
/// Lean: inductive NarInfoError
enum class narinfo_error_t : std::uint8_t {
  missing_field,
  invalid_field,
  duplicate_field,
  unknown_field,
  invalid_format,
};

/// Serialize narinfo to text format
/// Lean: def serializeNarInfo
[[nodiscard]] inline auto serialize_narinfo(const narinfo_t& ni) -> std::string {
  std::string result;
  result += \"StorePath: \" + ni.store_path + \"\\n\";
  result += \"URL: \" + ni.url + \"\\n\";
  result += \"Compression: \";
  result += compression_to_string(ni.compression);
  result += \"\\n\";
  result += \"FileSize: \" + std::to_string(ni.file_size) + \"\\n\";
  if (ni.file_hash) {
    result += \"FileHash: \" + *ni.file_hash + \"\\n\";
  }
  result += \"NarSize: \" + std::to_string(ni.nar_size) + \"\\n\";
  result += \"NarHash: \" + ni.nar_hash + \"\\n\";
  if (!ni.references.empty()) {
    result += \"References:\";
    for (const auto& ref : ni.references) {
      result += \" \" + ref;
    }
    result += \"\\n\";
  }
  if (ni.deriver) {
    result += \"Deriver: \" + *ni.deriver + \"\\n\";
  }
  for (const auto& sig : ni.sigs) {
    result += \"Sig: \" + sig.key_name + \":\" + sig.sig + \"\\n\";
  }
  if (ni.ca) {
    result += \"CA: \" + *ni.ca + \"\\n\";
  }
  return result;
}

/// Parse narinfo from text
[[nodiscard]] auto parse_narinfo(std::string_view text) -> parse_result_t<narinfo_t>;
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- DERIVATION FORMAT
-- ═══════════════════════════════════════════════════════════════════════════════

def genDrvFormat : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// Derivation (.drv) ATerm Format
// Generated from: Cornell.Drv
// ═══════════════════════════════════════════════════════════════════════════════

/// Derivation output
/// Lean: structure DrvOutput
struct drv_output_t {
  std::string name;       // e.g., \"out\", \"dev\", \"lib\"
  std::string path;       // store path (may be empty for floating CA)
  std::string hash_algo;  // e.g., \"sha256\", \"\" for input-addressed
  std::string hash;       // expected hash (empty for input-addressed)
};

/// Derivation input (another derivation)
/// Lean: structure DrvInput
struct drv_input_t {
  std::string drv_path;              // path to the .drv file
  std::vector<std::string> output_names;  // which outputs we need
};

/// Derivation
/// Lean: structure Derivation
struct derivation_t {
  std::vector<drv_output_t> outputs;
  std::vector<drv_input_t> input_drvs;
  std::vector<std::string> input_srcs;
  std::string platform;
  std::string builder;
  std::vector<std::string> args;
  std::vector<std::pair<std::string, std::string>> env;
};

/// Derivation parse error
/// Lean: inductive DrvError  
enum class drv_error_t : std::uint8_t {
  invalid_aterm,
  missing_field,
  invalid_output,
  invalid_input,
  truncated,
};

/// Escape string for ATerm format
/// Lean: def escapeAterm
[[nodiscard]] inline auto escape_aterm(std::string_view s) -> std::string {
  std::string result;
  result.reserve(s.size());
  for (char c : s) {
    switch (c) {
      case '\\\\': result += \"\\\\\\\\\"; break;
      case '\"': result += \"\\\\\\\"\"; break;
      case '\\n': result += \"\\\\n\"; break;
      case '\\r': result += \"\\\\r\"; break;
      case '\\t': result += \"\\\\t\"; break;
      default: result += c;
    }
  }
  return result;
}

/// Quote string in ATerm format
[[nodiscard]] inline auto quote_aterm(std::string_view s) -> std::string {
  return \"\\\"\" + escape_aterm(s) + \"\\\"\";
}

/// Serialize derivation output to ATerm
[[nodiscard]] inline auto serialize_drv_output(const drv_output_t& o) -> std::string {
  return \"(\" + quote_aterm(o.name) + \",\" + quote_aterm(o.path) + \",\" 
       + quote_aterm(o.hash_algo) + \",\" + quote_aterm(o.hash) + \")\";
}

/// Serialize derivation input to ATerm
[[nodiscard]] inline auto serialize_drv_input(const drv_input_t& i) -> std::string {
  std::string outputs = \"[\";
  for (std::size_t j = 0; j < i.output_names.size(); ++j) {
    if (j > 0) outputs += \",\";
    outputs += quote_aterm(i.output_names[j]);
  }
  outputs += \"]\";
  return \"(\" + quote_aterm(i.drv_path) + \",\" + outputs + \")\";
}

/// Serialize derivation to ATerm format
/// Lean: def serializeDerivation
[[nodiscard]] inline auto serialize_derivation(const derivation_t& drv) -> std::string {
  std::string result = \"Derive([\";
  
  // Outputs
  for (std::size_t i = 0; i < drv.outputs.size(); ++i) {
    if (i > 0) result += \",\";
    result += serialize_drv_output(drv.outputs[i]);
  }
  result += \"],[\";
  
  // Input derivations
  for (std::size_t i = 0; i < drv.input_drvs.size(); ++i) {
    if (i > 0) result += \",\";
    result += serialize_drv_input(drv.input_drvs[i]);
  }
  result += \"],[\";
  
  // Input sources
  for (std::size_t i = 0; i < drv.input_srcs.size(); ++i) {
    if (i > 0) result += \",\";
    result += quote_aterm(drv.input_srcs[i]);
  }
  result += \"],\";
  
  // Platform, builder
  result += quote_aterm(drv.platform) + \",\" + quote_aterm(drv.builder) + \",[\";
  
  // Args
  for (std::size_t i = 0; i < drv.args.size(); ++i) {
    if (i > 0) result += \",\";
    result += quote_aterm(drv.args[i]);
  }
  result += \"],[\";
  
  // Environment
  for (std::size_t i = 0; i < drv.env.size(); ++i) {
    if (i > 0) result += \",\";
    result += \"(\" + quote_aterm(drv.env[i].first) + \",\" 
            + quote_aterm(drv.env[i].second) + \")\";
  }
  result += \"])\";
  
  return result;
}

/// Parse derivation from ATerm format
[[nodiscard]] auto parse_derivation(std::string_view text) -> parse_result_t<derivation_t>;
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- FOOTER
-- ═══════════════════════════════════════════════════════════════════════════════

def genFooter : String :=
"}  // namespace cornell::nix

// ═══════════════════════════════════════════════════════════════════════════════
// Implementation Notes
// ═══════════════════════════════════════════════════════════════════════════════
//
// The parse_nar, parse_narinfo, and parse_derivation functions are declared but
// not defined here. They should be implemented in a separate .cpp file that
// #includes this header.
//
// Verified properties from Lean:
// - NAR serialization is deterministic (nar_serialize_deterministic)
// - NAR entries must be sorted (nar_entries_sorted)  
// - NarInfo serialization contains required fields (narinfo_has_required_fields)
// - Derivation serialization is deterministic (drv_serialize_deterministic)
// - Derivation starts with \"Derive(\" (drv_starts_with_derive)
//
// Reset-on-ambiguity:
// - Parse errors return parse_result_t with error set
// - Callers should reset state and retry from known-good position
// - DoS limits enforced: max_nar_depth, max_entry_name_len, max_file_size
// ═══════════════════════════════════════════════════════════════════════════════
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- FULL FILE GENERATION
-- ═══════════════════════════════════════════════════════════════════════════════

def genAll : String :=
  genHeader ++ "\n" ++
  genWirePrimitives ++ "\n" ++
  genNarFormat ++ "\n" ++
  genNarInfoFormat ++ "\n" ++
  genDrvFormat ++ "\n" ++
  genFooter

end Cornell.ExtractNix

-- Main function for executable
def main : IO Unit := do
  IO.println Cornell.ExtractNix.genAll
