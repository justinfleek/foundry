/-
  Cornell.ExtractSigil - C++ Code Generation for SIGIL State Machine
  
  Generates evring-compatible sigil.h from the Lean specification in Foundry.Cornell.Sigil.
  The generated code exactly matches the verified Lean implementation.
  
  ## Design
  
  Rather than generating from reflection (complex), we generate from explicit
  definitions that mirror the Lean types. The Lean code serves as the spec,
  and we have manual review to ensure the generated code matches.
  
  Future: Use Lean metaprogramming to extract directly from the inductive types.
  
  ## Generated Code
  
  - `parse_mode` enum
  - `ambiguity_reason` enum
  - `sigil_state` struct
  - `init_sigil_state()` function
  - `reset_sigil_state()` function
  - `handle_control_byte()` function with all mode transitions
  - `sigil_machine` satisfying `evring::machine` concept
-/

import Foundry.Cornell.Sigil

namespace Cornell.ExtractSigil

-- ═══════════════════════════════════════════════════════════════════════════════
-- FILE HEADER
-- ═══════════════════════════════════════════════════════════════════════════════

def genHeader : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// GENERATED BY CORNELL - DO NOT EDIT
// Source: Cornell.ExtractSigil (from Foundry.Cornell.Sigil specification)
//
// This file is extracted from the verified Lean specification.
// The state machine and reset-on-ambiguity behavior are proven correct in Lean.
//
// To regenerate:
//   lake build && lake exe cornell_sigil_gen > path/to/sigil.h
// ═══════════════════════════════════════════════════════════════════════════════

#pragma once

#include <cstdint>
#include <optional>
#include <span>
#include <variant>
#include <vector>

#include \"straylight/evring/machine.h\"

namespace evring::sigil {
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- CONSTANTS
-- ═══════════════════════════════════════════════════════════════════════════════

def genConstants : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// Constants
// Generated from: Foundry.Cornell.Sigil.Opcode
// ═══════════════════════════════════════════════════════════════════════════════

// Control opcodes (0xC0-0xCF)
inline constexpr std::uint8_t op_chunk_end = 0xC0;
inline constexpr std::uint8_t op_tool_call_start = 0xC1;
inline constexpr std::uint8_t op_tool_call_end = 0xC2;
inline constexpr std::uint8_t op_think_start = 0xC3;
inline constexpr std::uint8_t op_think_end = 0xC4;
inline constexpr std::uint8_t op_code_block_start = 0xC5;
inline constexpr std::uint8_t op_code_block_end = 0xC6;
inline constexpr std::uint8_t op_flush = 0xC7;
// 0xC8-0xCE reserved
inline constexpr std::uint8_t op_stream_end = 0xCF;

// Special bytes
inline constexpr std::uint8_t hot_token_reserved = 0x7F;
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- TOKEN TYPE
-- ═══════════════════════════════════════════════════════════════════════════════

def genTokenType : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// Token type
// Generated from: Foundry.Cornell.Sigil.TokenId
// ═══════════════════════════════════════════════════════════════════════════════

using token_id = std::uint32_t;
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- BYTE CLASSIFICATION
-- ═══════════════════════════════════════════════════════════════════════════════

def genByteClassification : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// Byte classification
// Generated from: Foundry.Cornell.Sigil.isHotByte, isExtendedByte, isControlByte
// ═══════════════════════════════════════════════════════════════════════════════

/// Is this byte a hot token? (0x00-0x7E, not 0x7F)
/// Lean: def isHotByte (b : UInt8) : Bool := b < 0x7F
[[nodiscard]] constexpr auto is_hot_byte(std::uint8_t byte) noexcept -> bool {
  return byte < hot_token_reserved;
}

/// Is this byte an extended token escape? (0x80-0xBF)
/// Lean: def isExtendedByte (b : UInt8) : Bool := b >= 0x80 && b < 0xC0
[[nodiscard]] constexpr auto is_extended_byte(std::uint8_t byte) noexcept -> bool {
  return (byte & 0xC0) == 0x80;
}

/// Is this byte a control opcode? (0xC0-0xCF)
/// Lean: def isControlByte (b : UInt8) : Bool := b >= 0xC0 && b < 0xD0
[[nodiscard]] constexpr auto is_control_byte(std::uint8_t byte) noexcept -> bool {
  return (byte & 0xF0) == 0xC0;
}

/// Is this a reserved control opcode? (0xC8-0xCE)
[[nodiscard]] constexpr auto is_reserved_control(std::uint8_t byte) noexcept -> bool {
  return byte >= 0xC8 && byte <= 0xCE;
}
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- PARSE MODE
-- ═══════════════════════════════════════════════════════════════════════════════

def genParseMode : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// Parse mode
// Generated from: Foundry.Cornell.Sigil.ParseMode
// ═══════════════════════════════════════════════════════════════════════════════

enum class parse_mode : std::uint8_t {
  text,       // Lean: | text
  think,      // Lean: | think  
  tool_call,  // Lean: | toolCall
  code_block, // Lean: | codeBlock
};
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- AMBIGUITY REASONS
-- ═══════════════════════════════════════════════════════════════════════════════

def genAmbiguityReason : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// Ambiguity reasons
// Generated from: Foundry.Cornell.Sigil.AmbiguityReason
// ═══════════════════════════════════════════════════════════════════════════════

enum class ambiguity_reason : std::uint8_t {
  unmatched_mode_end,  // Lean: | unmatchedModeEnd : ParseMode → AmbiguityReason
  nested_mode_start,   // Lean: | nestedModeStart : ParseMode → ParseMode → AmbiguityReason
  reserved_opcode,     // Lean: | reservedOpcode : UInt8 → AmbiguityReason
  varint_overflow,     // Lean: | varintOverflow : AmbiguityReason
  upstream_error,      // Lean: | upstreamError : String → AmbiguityReason
};
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- CHUNK CONTENT TYPES
-- ═══════════════════════════════════════════════════════════════════════════════

def genChunkContent : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// Chunk content types
// Generated from: Foundry.Cornell.Sigil.ChunkContent
// ═══════════════════════════════════════════════════════════════════════════════

struct text_content {
  std::vector<token_id> tokens;
};

struct think_content {
  std::vector<token_id> tokens;
};

struct tool_call_content {
  std::vector<token_id> tokens;
};

struct code_block_content {
  std::vector<token_id> tokens;
};

struct stream_end_content {};

struct decode_error_content {
  std::vector<std::byte> bytes;
};

struct ambiguity_reset_content {
  ambiguity_reason reason;
  parse_mode current_mode;
  parse_mode attempted_mode;
  std::uint8_t opcode;
};

using chunk_content = std::variant<
  text_content,
  think_content,
  tool_call_content,
  code_block_content,
  stream_end_content,
  decode_error_content,
  ambiguity_reset_content
>;
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- CHUNK
-- ═══════════════════════════════════════════════════════════════════════════════

def genChunk : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// Chunk
// Generated from: Foundry.Cornell.Sigil.Chunk
// ═══════════════════════════════════════════════════════════════════════════════

struct chunk {
  chunk_content content;
  bool complete;  // Lean: complete : Bool  -- True if ends on semantic boundary
};
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- PARSE RESULT
-- ═══════════════════════════════════════════════════════════════════════════════

def genParseResult : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// Parse result (tri-state)
// Generated from: Foundry.Cornell.Sigil.StrictParseResult
// ═══════════════════════════════════════════════════════════════════════════════

template <typename T>
struct parse_result {
  struct ok_t {
    T value;
    std::size_t consumed;
  };
  struct incomplete_t {};
  struct ambiguous_t {
    ambiguity_reason reason;
  };

  std::variant<ok_t, incomplete_t, ambiguous_t> data;

  [[nodiscard]] auto is_ok() const noexcept -> bool {
    return std::holds_alternative<ok_t>(data);
  }
  [[nodiscard]] auto is_incomplete() const noexcept -> bool {
    return std::holds_alternative<incomplete_t>(data);
  }
  [[nodiscard]] auto is_ambiguous() const noexcept -> bool {
    return std::holds_alternative<ambiguous_t>(data);
  }

  [[nodiscard]] auto get_ok() const -> ok_t const& { return std::get<ok_t>(data); }

  static auto ok(T value, std::size_t consumed) -> parse_result {
    return parse_result{ok_t{std::move(value), consumed}};
  }
  static auto incomplete() -> parse_result { return parse_result{incomplete_t{}}; }
  static auto ambiguous(ambiguity_reason reason) -> parse_result {
    return parse_result{ambiguous_t{reason}};
  }
};
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- VARINT DECODING
-- ═══════════════════════════════════════════════════════════════════════════════

def genVarint : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// Varint decoding (LEB128)
// Generated from: Foundry.Cornell.Sigil.parseVarint
// ═══════════════════════════════════════════════════════════════════════════════

/// Decode LEB128 varint from byte span.
/// Lean: def parseVarint (bs : Bytes) : StrictParseResult (UInt32 × Nat)
[[nodiscard]] inline auto decode_varint(std::span<const std::byte> bytes) noexcept
    -> std::optional<std::pair<token_id, std::size_t>> {
  if (bytes.empty()) {
    return std::nullopt;
  }

  token_id acc = 0;
  int shift = 0;

  for (std::size_t offset = 0; offset < bytes.size(); ++offset) {
    auto const byte = static_cast<std::uint8_t>(bytes[offset]);
    acc |= static_cast<token_id>(byte & 0x7F) << shift;

    if ((byte & 0x80) == 0) {
      return std::make_pair(acc, offset + 1);
    }

    shift += 7;
    // Lean: else if shift >= 28 then .ambiguous .varintOverflow
    if (shift >= 35) {
      return std::nullopt;  // Overflow
    }
  }

  return std::nullopt;  // Incomplete
}
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- DECODE STATE
-- ═══════════════════════════════════════════════════════════════════════════════

def genDecodeState : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// Decode state
// Generated from: Foundry.Cornell.Sigil.DecodeState
// ═══════════════════════════════════════════════════════════════════════════════

struct sigil_state {
  parse_mode mode = parse_mode::text;       // Lean: parseMode : ParseMode
  std::vector<token_id> buffer;             // Lean: buffer : List TokenId
  std::vector<std::byte> leftover;          // Lean: leftover : Bytes
  std::vector<chunk> chunks;                // Accumulated chunks
  bool stream_done = false;

  [[nodiscard]] auto is_done() const noexcept -> bool { return stream_done; }
};

/// Initial decode state (the unique ground state)
/// Lean: def initDecodeState : DecodeState := { parseMode := .text, buffer := [], leftover := ByteArray.empty }
[[nodiscard]] inline auto init_sigil_state() -> sigil_state { return sigil_state{}; }

/// Reset to ground state, discarding any accumulated context
/// Lean: def resetDecodeState (_s : DecodeState) : DecodeState := initDecodeState
/// 
/// Proven properties (from Foundry.Cornell.Sigil):
///   - reset_is_ground: ∀ s, resetDecodeState s = initDecodeState
///   - no_leakage: ∀ s₁ s₂, resetDecodeState s₁ = resetDecodeState s₂
///   - reset_idempotent: ∀ s, resetDecodeState (resetDecodeState s) = resetDecodeState s
[[nodiscard]] inline auto reset_sigil_state() -> sigil_state { return sigil_state{}; }
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- CHUNK BUILDING
-- ═══════════════════════════════════════════════════════════════════════════════

def genBuildChunk : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// Chunk building
// Generated from: Foundry.Cornell.Sigil.buildChunk
// ═══════════════════════════════════════════════════════════════════════════════

[[nodiscard]] inline auto build_chunk(sigil_state const& state, bool complete) -> chunk {
  chunk_content content;

  // Lean: let content := match state.parseMode with
  switch (state.mode) {
  case parse_mode::text:
    content = text_content{state.buffer};
    break;
  case parse_mode::think:
    content = think_content{state.buffer};
    break;
  case parse_mode::tool_call:
    content = tool_call_content{state.buffer};
    break;
  case parse_mode::code_block:
    content = code_block_content{state.buffer};
    break;
  }

  return chunk{std::move(content), complete};
}
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- HANDLE CONTROL
-- ═══════════════════════════════════════════════════════════════════════════════

def genHandleControl : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// Control byte handling
// Generated from: Foundry.Cornell.Sigil.handleControl
//
// This is where ambiguity detection happens. The Lean proofs guarantee:
//   - handleControl_reserved_resets: reserved opcodes always reset
//   - handleControl_toolCallStart_think_resets: nested starts reset
//   - handleControl_toolCallEnd_text_resets: unmatched ends reset
//   - handleControl_ambiguity_is_ground: all resets produce initDecodeState
// ═══════════════════════════════════════════════════════════════════════════════

struct control_result {
  sigil_state new_state;
  std::optional<chunk> emitted_chunk;
  std::size_t consumed;
};

[[nodiscard]] inline auto handle_control_byte(sigil_state state, std::uint8_t opcode)
    -> control_result {
  switch (opcode) {
  
  // Lean: | .chunkEnd => let chunk := buildChunk state true
  //                      ({ state with buffer := [] }, some chunk)
  case op_chunk_end: {
    auto emitted = build_chunk(state, true);
    state.buffer.clear();
    return {std::move(state), std::move(emitted), 1};
  }

  // Lean: | .toolCallStart =>
  //         match state.parseMode with
  //         | .text => ... valid transition ...
  //         | mode => ... AMBIGUITY: nested mode start ...
  case op_tool_call_start: {
    if (state.mode != parse_mode::text) {
      auto reset = reset_sigil_state();
      chunk amb{ambiguity_reset_content{ambiguity_reason::nested_mode_start, state.mode,
                                        parse_mode::tool_call, opcode}, true};
      return {std::move(reset), std::move(amb), 1};
    }
    std::optional<chunk> pending;
    if (!state.buffer.empty()) {
      pending = build_chunk(state, false);
    }
    state.mode = parse_mode::tool_call;
    state.buffer.clear();
    return {std::move(state), std::move(pending), 1};
  }

  // Lean: | .toolCallEnd =>
  //         match state.parseMode with
  //         | .toolCall => ... valid transition ...
  //         | mode => ... AMBIGUITY: end without matching start ...
  case op_tool_call_end: {
    if (state.mode != parse_mode::tool_call) {
      auto reset = reset_sigil_state();
      chunk amb{ambiguity_reset_content{ambiguity_reason::unmatched_mode_end, state.mode,
                                        parse_mode::tool_call, opcode}, true};
      return {std::move(reset), std::move(amb), 1};
    }
    auto emitted = build_chunk(state, true);
    state.mode = parse_mode::text;
    state.buffer.clear();
    return {std::move(state), std::move(emitted), 1};
  }

  case op_think_start: {
    if (state.mode != parse_mode::text) {
      auto reset = reset_sigil_state();
      chunk amb{ambiguity_reset_content{ambiguity_reason::nested_mode_start, state.mode,
                                        parse_mode::think, opcode}, true};
      return {std::move(reset), std::move(amb), 1};
    }
    std::optional<chunk> pending;
    if (!state.buffer.empty()) {
      pending = build_chunk(state, false);
    }
    state.mode = parse_mode::think;
    state.buffer.clear();
    return {std::move(state), std::move(pending), 1};
  }

  case op_think_end: {
    if (state.mode != parse_mode::think) {
      auto reset = reset_sigil_state();
      chunk amb{ambiguity_reset_content{ambiguity_reason::unmatched_mode_end, state.mode,
                                        parse_mode::think, opcode}, true};
      return {std::move(reset), std::move(amb), 1};
    }
    auto emitted = build_chunk(state, true);
    state.mode = parse_mode::text;
    state.buffer.clear();
    return {std::move(state), std::move(emitted), 1};
  }

  case op_code_block_start: {
    if (state.mode != parse_mode::text) {
      auto reset = reset_sigil_state();
      chunk amb{ambiguity_reset_content{ambiguity_reason::nested_mode_start, state.mode,
                                        parse_mode::code_block, opcode}, true};
      return {std::move(reset), std::move(amb), 1};
    }
    std::optional<chunk> pending;
    if (!state.buffer.empty()) {
      pending = build_chunk(state, false);
    }
    state.mode = parse_mode::code_block;
    state.buffer.clear();
    return {std::move(state), std::move(pending), 1};
  }

  case op_code_block_end: {
    if (state.mode != parse_mode::code_block) {
      auto reset = reset_sigil_state();
      chunk amb{ambiguity_reset_content{ambiguity_reason::unmatched_mode_end, state.mode,
                                        parse_mode::code_block, opcode}, true};
      return {std::move(reset), std::move(amb), 1};
    }
    auto emitted = build_chunk(state, true);
    state.mode = parse_mode::text;
    state.buffer.clear();
    return {std::move(state), std::move(emitted), 1};
  }

  // Lean: | .flush => let chunk := buildChunk state false
  //                   ({ state with buffer := [] }, some chunk)
  case op_flush: {
    auto emitted = build_chunk(state, false);
    state.buffer.clear();
    return {std::move(state), std::move(emitted), 1};
  }

  // Lean: | .streamEnd => let chunk := if state.buffer.isEmpty 
  //                         then { content := ChunkContent.streamEnd, complete := true }
  //                         else buildChunk state true
  //                       (initDecodeState, some chunk)
  case op_stream_end: {
    chunk emitted;
    if (state.buffer.empty()) {
      emitted = chunk{stream_end_content{}, true};
    } else {
      emitted = build_chunk(state, true);
    }
    state = reset_sigil_state();
    state.stream_done = true;
    return {std::move(state), std::move(emitted), 1};
  }

  default:
    // Lean: | .reserved code => let chunk := { content := ChunkContent.ambiguityReset (.reservedOpcode code), complete := true }
    //                          (initDecodeState, some chunk)
    if (is_reserved_control(opcode)) {
      auto reset = reset_sigil_state();
      chunk amb{ambiguity_reset_content{ambiguity_reason::reserved_opcode, state.mode,
                                        parse_mode::text, opcode}, true};
      return {std::move(reset), std::move(amb), 1};
    }
    // Unknown control outside reserved range, ignore
    return {std::move(state), std::nullopt, 1};
  }
}
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- BYTE PROCESSING
-- ═══════════════════════════════════════════════════════════════════════════════

def genByteProcessing : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// Byte processing
// Generated from: Foundry.Cornell.Sigil.decodeByte
// ═══════════════════════════════════════════════════════════════════════════════

struct byte_result {
  sigil_state new_state;
  std::optional<chunk> emitted_chunk;
  std::size_t consumed;
  bool need_more;
};

[[nodiscard]] inline auto process_byte(sigil_state state, std::span<const std::byte> input)
    -> byte_result {
  if (input.empty()) {
    return {std::move(state), std::nullopt, 0, false};
  }

  auto const byte = static_cast<std::uint8_t>(input[0]);
  auto const rest = input.subspan(1);

  // Lean: if isHotByte b then
  //         let tokenId := b.toUInt32
  //         ({ state with buffer := tokenId :: state.buffer }, none)
  if (is_hot_byte(byte)) {
    state.buffer.push_back(static_cast<token_id>(byte));
    return {std::move(state), std::nullopt, 1, false};
  }

  // Extended token (varint follows)
  if (is_extended_byte(byte)) {
    auto varint_result = decode_varint(rest);
    if (!varint_result) {
      return {std::move(state), std::nullopt, 0, true};  // Incomplete
    }
    auto [token, varint_len] = *varint_result;
    state.buffer.push_back(token);
    return {std::move(state), std::nullopt, 1 + varint_len, false};
  }

  // Lean: else if isControlByte b then
  //         match decodeOpcode b with
  //         | some op => handleControl state op
  if (is_control_byte(byte)) {
    auto ctrl = handle_control_byte(std::move(state), byte);
    return {std::move(ctrl.new_state), std::move(ctrl.emitted_chunk), ctrl.consumed, false};
  }

  // Reserved/unknown - ignore
  return {std::move(state), std::nullopt, 1, false};
}

inline auto process_bytes(sigil_state state, std::span<const std::byte> input)
    -> std::pair<sigil_state, std::vector<chunk>> {
  std::vector<chunk> chunks;
  std::size_t offset = 0;

  while (offset < input.size()) {
    auto result = process_byte(std::move(state), input.subspan(offset));
    state = std::move(result.new_state);

    if (result.emitted_chunk) {
      chunks.push_back(std::move(*result.emitted_chunk));
    }

    if (result.need_more) {
      state.leftover.assign(input.begin() + offset, input.end());
      break;
    }

    if (result.consumed == 0) {
      break;
    }

    offset += result.consumed;
  }

  if (offset >= input.size()) {
    state.leftover.clear();
  }

  return {std::move(state), std::move(chunks)};
}
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- SIGIL MACHINE
-- ═══════════════════════════════════════════════════════════════════════════════

def genSigilMachine : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// SIGIL Machine
// Implements evring::machine concept
// ═══════════════════════════════════════════════════════════════════════════════

struct sigil_machine {
  using state_type = sigil_state;

  [[nodiscard]] auto initial() const -> state_type { return init_sigil_state(); }

  [[nodiscard]] auto step(state_type state, event const& ev) const -> step_result<state_type> {
    std::vector<std::byte> input;
    input.reserve(state.leftover.size() + ev.data.size());
    input.insert(input.end(), state.leftover.begin(), state.leftover.end());
    input.insert(input.end(), ev.data.begin(), ev.data.end());

    auto [new_state, chunks] = process_bytes(std::move(state), input);

    for (auto& c : chunks) {
      new_state.chunks.push_back(std::move(c));
    }

    return {std::move(new_state), {}};
  }

  [[nodiscard]] auto done(state_type const& state) const -> bool { return state.stream_done; }

  [[nodiscard]] static auto take_chunks(state_type& state) -> std::vector<chunk> {
    std::vector<chunk> result;
    std::swap(result, state.chunks);
    return result;
  }
};

// Verify it satisfies the machine concept
static_assert(machine<sigil_machine>);
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- FOOTER
-- ═══════════════════════════════════════════════════════════════════════════════

def genFooter : String :=
"
} // namespace evring::sigil
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- COMPLETE FILE GENERATION
-- ═══════════════════════════════════════════════════════════════════════════════

def genSigilH : String :=
  genHeader ++ "\n" ++
  genConstants ++ "\n" ++
  genTokenType ++ "\n" ++
  genByteClassification ++ "\n" ++
  genParseMode ++ "\n" ++
  genAmbiguityReason ++ "\n" ++
  genChunkContent ++ "\n" ++
  genChunk ++ "\n" ++
  genParseResult ++ "\n" ++
  genVarint ++ "\n" ++
  genDecodeState ++ "\n" ++
  genBuildChunk ++ "\n" ++
  genHandleControl ++ "\n" ++
  genByteProcessing ++ "\n" ++
  genSigilMachine ++ "\n" ++
  genFooter

#eval IO.println genSigilH

end Cornell.ExtractSigil

-- Main entry point
def main : IO Unit := do
  IO.println Cornell.ExtractSigil.genSigilH
