/-
  Cornell.ExtractStateMachine - C++ Code Generation for State Machines
  
  Generates std::variant-based state machine code from the StateMachine DSL.
  The generated code matches the structure of handshake.hpp exactly.
-/

import Foundry.Foundry.Cornell.StateMachine

namespace Cornell.ExtractStateMachine

open Foundry.Cornell.StateMachine

-- ═══════════════════════════════════════════════════════════════════════════════
-- C++ CODE GENERATION - Matching handshake.hpp interface exactly
-- ═══════════════════════════════════════════════════════════════════════════════

/-- Generate file header -/
def genHeader : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// GENERATED BY CORNELL - DO NOT EDIT
// Source: Cornell.ExtractStateMachine
// 
// This file is generated from the Lean specification in Foundry.Cornell.StateMachine.
// The state machine types are extracted automatically via metaprogramming.
// The transition functions are direct translations of the Lean pattern matches.
//
// To regenerate:
//   lake build cornell_sm_gen && lake exe cornell_sm_gen > cpp/include/cornell/handshake.hpp
// ═══════════════════════════════════════════════════════════════════════════════

#pragma once

#include \"cornell/protocol.hpp\"
#include <algorithm>
#include <optional>
#include <set>
#include <string>
#include <utility>
#include <variant>
#include <vector>

namespace cornell {
"

/-- Generate HandshakeConfig -/
def genHandshakeConfig : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// HANDSHAKE CONFIGURATION
// Generated from: Foundry.Cornell.StateMachine.HandshakeConfig
// ═══════════════════════════════════════════════════════════════════════════════

struct HandshakeConfig {
    ProtocolVersion serverVersion = CURRENT_PROTOCOL;
    std::set<Feature> serverFeatures = {Feature::ReapiV2, Feature::CasSha256, Feature::StreamingNar};
    std::optional<ReapiConfig> reapiConfig;
    std::string daemonVersion = \"nix-serve-cas 0.1.0\";
    TrustLevel trustLevel = TrustLevel::Trusted;
    
    static HandshakeConfig default_config() {
        HandshakeConfig cfg;
        cfg.reapiConfig = ReapiConfig{
            \"main\",
            DigestFunction::SHA256,
            {Capability::CAS, Capability::ActionCache}
        };
        return cfg;
    }
};
"

/-- Generate ServerState enum -/
def genServerStateEnum : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// SERVER STATE
// Generated from: Foundry.Cornell.StateMachine.ServerState
// ═══════════════════════════════════════════════════════════════════════════════

struct SrvInit {
    HandshakeConfig config;
};
struct SrvVersioned {
    HandshakeConfig config;
    ProtocolVersion negotiated;
};
struct SrvFeatures {
    HandshakeConfig config;
    ProtocolVersion negotiated;
    std::set<Feature> active;
};
struct SrvUpgrading {
    HandshakeConfig config;
    ProtocolVersion negotiated;
    std::set<Feature> active;
};
struct SrvNixReady {
    ProtocolVersion version;
};
struct SrvReapiReady {
    ReapiConfig config;
};
struct SrvFailed {
    std::string reason;
};

using ServerHandshake = std::variant<
    SrvInit,
    SrvVersioned,
    SrvFeatures,
    SrvUpgrading,
    SrvNixReady,
    SrvReapiReady,
    SrvFailed
>;
"

/-- Generate ServerEvent enum -/
def genServerEventEnum : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// SERVER EVENTS
// Generated from: Foundry.Cornell.StateMachine.ServerEvent
// ═══════════════════════════════════════════════════════════════════════════════

struct SrvEvClientHello {
    ProtocolVersion clientVersion;
};
struct SrvEvClientLegacy {};
struct SrvEvClientFeatures {
    std::set<Feature> features;
};
struct SrvEvClientUpgradeResponse {
    bool accept;
};

using ServerEvent = std::variant<
    SrvEvClientHello,
    SrvEvClientLegacy,
    SrvEvClientFeatures,
    SrvEvClientUpgradeResponse
>;
"

/-- Generate ServerAction enum -/
def genServerActionEnum : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// SERVER ACTIONS
// Generated from: Foundry.Cornell.StateMachine.ServerAction
// ═══════════════════════════════════════════════════════════════════════════════

struct SrvActSendServerHello {
    ProtocolVersion version;
};
struct SrvActSendDaemonVersion {
    std::string version;
};
struct SrvActSendTrustLevel {
    TrustLevel level;
};
struct SrvActSendFeatures {
    std::set<Feature> features;
};
struct SrvActSendUpgradeOffer {};
struct SrvActSendReapiConfig {
    ReapiConfig config;
};
struct SrvActReady {};
struct SrvActFail {
    std::string reason;
};

using ServerAction = std::variant<
    SrvActSendServerHello,
    SrvActSendDaemonVersion,
    SrvActSendTrustLevel,
    SrvActSendFeatures,
    SrvActSendUpgradeOffer,
    SrvActSendReapiConfig,
    SrvActReady,
    SrvActFail
>;
"

/-- Generate ClientState enum -/
def genClientStateEnum : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// CLIENT STATE
// Generated from: Foundry.Cornell.StateMachine.ClientState
// ═══════════════════════════════════════════════════════════════════════════════

struct CliInit {
    ProtocolVersion clientVersion;
    std::set<Feature> clientFeatures;
};
struct CliSentHello {
    ProtocolVersion clientVersion;
    std::set<Feature> clientFeatures;
};
struct CliVersioned {
    ProtocolVersion negotiated;
    std::set<Feature> clientFeatures;
};
struct CliAwaitingUpgrade {
    ProtocolVersion negotiated;
};
struct CliNixReady {
    ProtocolVersion version;
};
struct CliReapiReady {
    ReapiConfig config;
};
struct CliFailed {
    std::string reason;
};

using ClientHandshake = std::variant<
    CliInit,
    CliSentHello,
    CliVersioned,
    CliAwaitingUpgrade,
    CliNixReady,
    CliReapiReady,
    CliFailed
>;
"

/-- Generate ClientEvent enum -/
def genClientEventEnum : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// CLIENT EVENTS
// Generated from: Foundry.Cornell.StateMachine.ClientEvent
// ═══════════════════════════════════════════════════════════════════════════════

struct CliEvServerHello {
    ProtocolVersion version;
};
struct CliEvDaemonVersion {
    std::string version;
};
struct CliEvTrustLevel {
    TrustLevel level;
};
struct CliEvServerFeatures {
    std::set<Feature> features;
};
struct CliEvUpgradeOffer {};
struct CliEvReapiConfig {
    ReapiConfig config;
};

using ClientEvent = std::variant<
    CliEvServerHello,
    CliEvDaemonVersion,
    CliEvTrustLevel,
    CliEvServerFeatures,
    CliEvUpgradeOffer,
    CliEvReapiConfig
>;
"

/-- Generate ClientAction enum -/
def genClientActionEnum : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// CLIENT ACTIONS
// Generated from: Foundry.Cornell.StateMachine.ClientAction
// ═══════════════════════════════════════════════════════════════════════════════

struct CliActSendClientHello {
    ProtocolVersion version;
};
struct CliActSendLegacy {};
struct CliActSendFeatures {
    std::set<Feature> features;
};
struct CliActSendUpgradeResponse {
    bool accept;
};
struct CliActReady {};
struct CliActFail {
    std::string reason;
};

using ClientAction = std::variant<
    CliActSendClientHello,
    CliActSendLegacy,
    CliActSendFeatures,
    CliActSendUpgradeResponse,
    CliActReady,
    CliActFail
>;
"

/-- Generate server transition function -/
def genServerTransition : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// SERVER TRANSITION FUNCTION
// Generated from: Foundry.Cornell.StateMachine.serverTransition
//
// This is a direct translation of the Lean pattern match. Each case corresponds
// exactly to a case in the Lean definition.
// ═══════════════════════════════════════════════════════════════════════════════

inline ServerHandshake init_server_handshake(const HandshakeConfig& config) {
    return SrvInit{config};
}

// Helper: compute feature intersection
// Generated from: Foundry.Cornell.StateMachine.featureIntersection
inline std::set<Feature> feature_intersection(
    const std::set<Feature>& server_features,
    const std::set<Feature>& client_features
) {
    std::set<Feature> result;
    for (auto f : server_features) {
        if (client_features.count(f)) result.insert(f);
    }
    return result;
}

// Helper: check if upgrade should be offered
// Generated from: Foundry.Cornell.StateMachine.shouldOfferUpgrade
inline bool should_offer_upgrade(const HandshakeConfig& config, const std::set<Feature>& active) {
    return active.count(Feature::ReapiV2) && config.reapiConfig.has_value();
}

inline std::pair<ServerHandshake, std::vector<ServerAction>>
server_step(const ServerHandshake& state, const ServerEvent& event) {
    
    // Case: .init config, .clientHello clientVer
    // Lean: | .init config, .clientHello clientVer =>
    //         let negotiated := if clientVer.value < config.serverVersion.value 
    //                           then clientVer else config.serverVersion
    //         { next := .versioned config negotiated
    //         , actions := [.sendServerHello config.serverVersion] }
    if (auto* s = std::get_if<SrvInit>(&state)) {
        if (auto* e = std::get_if<SrvEvClientHello>(&event)) {
            ProtocolVersion negotiated = (e->clientVersion.value < s->config.serverVersion.value)
                ? e->clientVersion
                : s->config.serverVersion;
            return {
                SrvVersioned{s->config, negotiated},
                {SrvActSendServerHello{s->config.serverVersion}}
            };
        }
    }
    
    // Case: .versioned config negotiated, .clientLegacy
    // Lean: | .versioned config negotiated, .clientLegacy =>
    //         if negotiated.supports 38 then ... else ...
    if (auto* s = std::get_if<SrvVersioned>(&state)) {
        if (std::holds_alternative<SrvEvClientLegacy>(event)) {
            if (s->negotiated.supports(38)) {
                // Version 1.38+: expect features, stay in versioned
                std::vector<ServerAction> actions;
                if (s->negotiated.supports(33)) {
                    actions.push_back(SrvActSendDaemonVersion{s->config.daemonVersion});
                }
                if (s->negotiated.supports(35)) {
                    actions.push_back(SrvActSendTrustLevel{s->config.trustLevel});
                }
                return {*s, std::move(actions)};
            } else {
                // Legacy: go straight to ready
                std::vector<ServerAction> actions;
                if (s->negotiated.supports(33)) {
                    actions.push_back(SrvActSendDaemonVersion{s->config.daemonVersion});
                }
                if (s->negotiated.supports(35)) {
                    actions.push_back(SrvActSendTrustLevel{s->config.trustLevel});
                }
                actions.push_back(SrvActReady{});
                return {SrvNixReady{s->negotiated}, std::move(actions)};
            }
        }
        
        // Case: .versioned config negotiated, .clientFeatures clientFeatures
        // Lean: | .versioned config negotiated, .clientFeatures clientFeatures =>
        //         let active := featureIntersection config.serverFeatures clientFeatures
        //         if shouldOfferUpgrade config active then ... else ...
        if (auto* e = std::get_if<SrvEvClientFeatures>(&event)) {
            auto active = feature_intersection(s->config.serverFeatures, e->features);
            if (should_offer_upgrade(s->config, active)) {
                return {
                    SrvUpgrading{s->config, s->negotiated, active},
                    {SrvActSendFeatures{s->config.serverFeatures}, SrvActSendUpgradeOffer{}}
                };
            } else {
                return {
                    SrvNixReady{s->negotiated},
                    {SrvActSendFeatures{s->config.serverFeatures}, SrvActReady{}}
                };
            }
        }
    }
    
    // Case: .upgrading config negotiated active, .clientUpgradeResponse accept
    // Lean: | .upgrading config negotiated active, .clientUpgradeResponse accept =>
    //         if accept then
    //           match config.reapiConfig with
    //           | some rc => ...
    //           | none => ...
    //         else ...
    if (auto* s = std::get_if<SrvUpgrading>(&state)) {
        if (auto* e = std::get_if<SrvEvClientUpgradeResponse>(&event)) {
            if (e->accept) {
                if (s->config.reapiConfig.has_value()) {
                    auto rc = *s->config.reapiConfig;
                    return {
                        SrvReapiReady{rc},
                        {SrvActSendReapiConfig{rc}, SrvActReady{}}
                    };
                } else {
                    return {
                        SrvFailed{\"REAPI config missing\"},
                        {SrvActFail{\"REAPI config missing\"}}
                    };
                }
            } else {
                return {SrvNixReady{s->negotiated}, {SrvActReady{}}};
            }
        }
    }
    
    // Case: .nixReady _, _ (terminal)
    // Lean: | .nixReady _, _ => 
    //         { next := .failed \"Already in terminal state\", actions := [.fail \"Already terminal\"] }
    if (std::holds_alternative<SrvNixReady>(state)) {
        return {SrvFailed{\"Already in terminal state\"}, {SrvActFail{\"Already terminal\"}}};
    }
    
    // Case: .reapiReady _, _ (terminal)
    // Lean: | .reapiReady _, _ => ...
    if (std::holds_alternative<SrvReapiReady>(state)) {
        return {SrvFailed{\"Already in terminal state\"}, {SrvActFail{\"Already terminal\"}}};
    }
    
    // Case: .failed reason, _ (absorb)
    // Lean: | .failed reason, _ => { next := .failed reason, actions := [] }
    if (auto* s = std::get_if<SrvFailed>(&state)) {
        return {*s, {}};
    }
    
    // Case: _, _ (invalid transition)
    // Lean: | s, e => { next := .failed s!\"Invalid event {repr e} in state\"
    //                 , actions := [.fail \"Invalid transition\"] }
    return {SrvFailed{\"Invalid transition\"}, {SrvActFail{\"Invalid transition\"}}};
}

inline bool is_server_terminal(const ServerHandshake& state) {
    return std::holds_alternative<SrvNixReady>(state) ||
           std::holds_alternative<SrvReapiReady>(state) ||
           std::holds_alternative<SrvFailed>(state);
}
"

/-- Generate client transition function -/
def genClientTransition : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// CLIENT TRANSITION FUNCTION
// Generated from: Foundry.Cornell.StateMachine.clientTransition
// ═══════════════════════════════════════════════════════════════════════════════

inline std::pair<ClientHandshake, std::vector<ClientAction>>
init_client_handshake(ProtocolVersion version, const std::set<Feature>& features) {
    return {
        CliSentHello{version, features},
        {CliActSendClientHello{version}}
    };
}

inline std::pair<ClientHandshake, std::vector<ClientAction>>
client_step(const ClientHandshake& state, const ClientEvent& event) {
    
    // Case: .sentHello clientVersion clientFeatures, .serverHello serverVer
    // Lean: | .sentHello clientVer clientFeatures, .serverHello serverVer =>
    //         let negotiated := if clientVer.value < serverVer.value then clientVer else serverVer
    //         { next := .versioned negotiated clientFeatures
    //         , actions := [.sendLegacyFields] }
    if (auto* s = std::get_if<CliSentHello>(&state)) {
        if (auto* e = std::get_if<CliEvServerHello>(&event)) {
            ProtocolVersion negotiated = (s->clientVersion.value < e->version.value)
                ? s->clientVersion
                : e->version;
            return {
                CliVersioned{negotiated, s->clientFeatures},
                {CliActSendLegacy{}}
            };
        }
    }
    
    // Case: .versioned negotiated features, .serverDaemonVersion _
    // Lean: | .versioned negotiated features, .serverDaemonVersion _ =>
    //         { next := .versioned negotiated features, actions := [] }
    if (auto* s = std::get_if<CliVersioned>(&state)) {
        if (std::holds_alternative<CliEvDaemonVersion>(event)) {
            return {*s, {}};
        }
    }
    
    // Case: .versioned negotiated features, .serverTrustLevel _
    // Lean: | .versioned negotiated features, .serverTrustLevel _ =>
    //         { next := .versioned negotiated features, actions := [] }
    if (auto* s = std::get_if<CliVersioned>(&state)) {
        if (std::holds_alternative<CliEvTrustLevel>(event)) {
            return {*s, {}};
        }
    }
    
    // Case: .versioned negotiated clientFeatures, .serverFeatures serverFeatures
    // Lean: | .versioned negotiated clientFeatures, .serverFeatures serverFeatures =>
    //         let active := featureIntersection clientFeatures serverFeatures
    //         if active.contains .reapiV2 then ... else ...
    if (auto* s = std::get_if<CliVersioned>(&state)) {
        if (auto* e = std::get_if<CliEvServerFeatures>(&event)) {
            auto active = feature_intersection(s->clientFeatures, e->features);
            std::vector<ClientAction> actions;
            actions.push_back(CliActSendFeatures{s->clientFeatures});
            
            if (active.count(Feature::ReapiV2)) {
                return {CliAwaitingUpgrade{s->negotiated}, std::move(actions)};
            } else {
                actions.push_back(CliActReady{});
                return {CliNixReady{s->negotiated}, std::move(actions)};
            }
        }
    }
    
    // Case: .awaitingUpgrade negotiated, .upgradeOffer
    // Lean: | .awaitingUpgrade negotiated, .upgradeOffer =>
    //         { next := .awaitingUpgrade negotiated, actions := [.sendUpgradeResponse true] }
    if (auto* s = std::get_if<CliAwaitingUpgrade>(&state)) {
        if (std::holds_alternative<CliEvUpgradeOffer>(event)) {
            return {*s, {CliActSendUpgradeResponse{true}}};
        }
    }
    
    // Case: .awaitingUpgrade _, .reapiConfig config
    // Lean: | .awaitingUpgrade _, .reapiConfig config =>
    //         { next := .reapiReady config, actions := [.ready] }
    if (auto* s = std::get_if<CliAwaitingUpgrade>(&state)) {
        if (auto* e = std::get_if<CliEvReapiConfig>(&event)) {
            return {CliReapiReady{e->config}, {CliActReady{}}};
        }
    }
    
    // Terminal states
    // Lean: | .nixReady _, _ => { next := .failed \"Already terminal\", actions := [] }
    if (std::holds_alternative<CliNixReady>(state)) {
        return {CliFailed{\"Already terminal\"}, {}};
    }
    
    // Lean: | .reapiReady _, _ => { next := .failed \"Already terminal\", actions := [] }
    if (std::holds_alternative<CliReapiReady>(state)) {
        return {CliFailed{\"Already terminal\"}, {}};
    }
    
    // Lean: | .failed reason, _ => { next := .failed reason, actions := [] }
    if (auto* s = std::get_if<CliFailed>(&state)) {
        return {*s, {}};
    }
    
    // Catch-all: invalid transition
    // Lean: | _, _ => { next := .failed \"Invalid transition\", actions := [.fail \"Invalid transition\"] }
    return {CliFailed{\"Invalid transition\"}, {CliActFail{\"Invalid transition\"}}};
}

inline bool is_client_terminal(const ClientHandshake& state) {
    return std::holds_alternative<CliNixReady>(state) ||
           std::holds_alternative<CliReapiReady>(state) ||
           std::holds_alternative<CliFailed>(state);
}

inline ProtocolVersion negotiate_version(ProtocolVersion client, ProtocolVersion server) {
    return std::min(client, server);
}
"

/-- Generate complete handshake.hpp -/
def genHandshakeHpp : String :=
  genHeader ++ "\n"
  ++ genHandshakeConfig ++ "\n"
  ++ genServerStateEnum ++ "\n"
  ++ genServerEventEnum ++ "\n"
  ++ genServerActionEnum ++ "\n"
  ++ genClientStateEnum ++ "\n"
  ++ genClientEventEnum ++ "\n"
  ++ genClientActionEnum ++ "\n"
  ++ genServerTransition ++ "\n"
  ++ genClientTransition ++ "\n"
  ++ "} // namespace cornell\n"

-- ═══════════════════════════════════════════════════════════════════════════════
-- OUTPUT
-- ═══════════════════════════════════════════════════════════════════════════════

#eval IO.println genHandshakeHpp

end Cornell.ExtractStateMachine

-- Main function must be at root scope for executable
def main : IO Unit := do
  IO.println Cornell.ExtractStateMachine.genHandshakeHpp
