/-
  Cornell.ExtractZmtp - C++ Code Generation for ZMTP Protocol
  
  Generates evring-compatible zmtp.h from the Lean specification in Foundry.Cornell.Zmtp.
  The generated code exactly matches the verified Lean implementation.
  
  ## Design
  
  Rather than generating from reflection (complex), we generate from explicit
  definitions that mirror the Lean types. The Lean code serves as the spec,
  and we have manual review to ensure the generated code matches.
  
  ## Generated Code
  
  - `ambiguity_reason` enum
  - `mechanism` enum
  - `greeting` struct
  - `frame_header` struct
  - `frame` struct
  - `command_type` enum
  - `command` struct
  - `parse_result<T>` template
  - All parsing functions
  - `zmtp_machine` satisfying `evring::machine` concept
-/

import Foundry.Foundry.Cornell.Zmtp

namespace Cornell.ExtractZmtp

-- ═══════════════════════════════════════════════════════════════════════════════
-- FILE HEADER
-- ═══════════════════════════════════════════════════════════════════════════════

def genHeader : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// GENERATED BY CORNELL - DO NOT EDIT
// Source: Cornell.ExtractZmtp (from Foundry.Cornell.Zmtp specification)
//
// This file is extracted from the verified Lean specification.
// The parser functions and reset-on-ambiguity behavior are proven correct in Lean.
//
// Verified properties (from Foundry.Cornell.Zmtp):
//   - parseGreeting_deterministic: same bytes → same result
//   - greeting_exactly_64: greeting consumes exactly 64 bytes on success
//   - flags_unambiguous: with enough bytes, parsing is never incomplete
//   - reset_is_initial: reset always returns to initial state
//   - no_backtrack_greeting: parser never needs to re-read bytes
//
// To regenerate:
//   lake build && lake exe cornell_zmtp_gen > path/to/zmtp.h
// ═══════════════════════════════════════════════════════════════════════════════

#pragma once

#include <array>
#include <cstdint>
#include <cstring>
#include <span>
#include <string_view>
#include <variant>
#include <vector>

#include \"straylight/evring/machine.h\"

namespace evring::zmtp {
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- CONSTANTS
-- ═══════════════════════════════════════════════════════════════════════════════

def genConstants : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// Constants
// Generated from: Foundry.Cornell.Zmtp constants
// ═══════════════════════════════════════════════════════════════════════════════

// Lean: def signatureByte0 : UInt8 := 0xFF
inline constexpr std::uint8_t signature_byte_0 = 0xFF;
// Lean: def signatureByte9 : UInt8 := 0x7F
inline constexpr std::uint8_t signature_byte_9 = 0x7F;
// Lean: def versionMajor : UInt8 := 3
inline constexpr std::uint8_t version_major = 3;
// Lean: def versionMinor : UInt8 := 1
inline constexpr std::uint8_t version_minor = 1;
// Lean: def greetingSize : Nat := 64
inline constexpr std::size_t greeting_size = 64;
// Lean: def mechanismSize : Nat := 20
inline constexpr std::size_t mechanism_size = 20;
// Lean: def maxFrameSize : Nat := 256 * 1024 * 1024
inline constexpr std::size_t max_frame_size = 256 * 1024 * 1024;

// Flag bits
// Lean: def flagMore : UInt8 := 0x01
inline constexpr std::uint8_t flag_more = 0x01;
// Lean: def flagLong : UInt8 := 0x02
inline constexpr std::uint8_t flag_long = 0x02;
// Lean: def flagCommand : UInt8 := 0x04
inline constexpr std::uint8_t flag_command = 0x04;
// Lean: def flagReservedMask : UInt8 := 0xF8
inline constexpr std::uint8_t flag_reserved_mask = 0xF8;
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- AMBIGUITY REASON
-- ═══════════════════════════════════════════════════════════════════════════════

def genAmbiguityReason : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// Ambiguity reasons (triggers reset)
// Generated from: Foundry.Cornell.Zmtp.AmbiguityReason
// ═══════════════════════════════════════════════════════════════════════════════

// Lean: inductive AmbiguityReason where
//   | invalidSignature : UInt8 → UInt8 → AmbiguityReason
//   | unsupportedVersion : UInt8 → UInt8 → AmbiguityReason
//   | reservedFlagsSet : UInt8 → AmbiguityReason
//   | invalidCommandName : AmbiguityReason
//   | frameTooLarge : UInt64 → AmbiguityReason
//   | unexpectedCommand : String → AmbiguityReason
//   | mechanismMismatch : String → AmbiguityReason
enum class ambiguity_reason : std::uint8_t {
  invalid_signature,
  unsupported_version,
  reserved_flags_set,
  invalid_command_name,
  frame_too_large,
  unexpected_command,
  mechanism_mismatch,
};
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- PARSE RESULT
-- ═══════════════════════════════════════════════════════════════════════════════

def genParseResult : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// Parse result (tri-state: ok | incomplete | ambiguous)
// Generated from: Foundry.Cornell.Zmtp.StrictParseResult
// ═══════════════════════════════════════════════════════════════════════════════

// Lean: inductive StrictParseResult (α : Type) where
//   | ok : α → Bytes → StrictParseResult α
//   | incomplete : Nat → StrictParseResult α
//   | ambiguous : AmbiguityReason → StrictParseResult α
template <typename T>
struct parse_result {
  struct ok_t {
    T value;
    std::size_t consumed;
  };
  struct incomplete_t {
    std::size_t needed;
  };
  struct ambiguous_t {
    ambiguity_reason reason;
  };

  std::variant<ok_t, incomplete_t, ambiguous_t> data;

  [[nodiscard]] auto is_ok() const noexcept -> bool {
    return std::holds_alternative<ok_t>(data);
  }
  [[nodiscard]] auto is_incomplete() const noexcept -> bool {
    return std::holds_alternative<incomplete_t>(data);
  }
  [[nodiscard]] auto is_ambiguous() const noexcept -> bool {
    return std::holds_alternative<ambiguous_t>(data);
  }

  [[nodiscard]] auto get_ok() const -> ok_t const& { return std::get<ok_t>(data); }
  [[nodiscard]] auto get_incomplete() const -> incomplete_t const& {
    return std::get<incomplete_t>(data);
  }
  [[nodiscard]] auto get_ambiguous() const -> ambiguous_t const& {
    return std::get<ambiguous_t>(data);
  }

  static auto ok(T value, std::size_t consumed) -> parse_result {
    return parse_result{ok_t{std::move(value), consumed}};
  }
  static auto incomplete(std::size_t needed) -> parse_result {
    return parse_result{incomplete_t{needed}};
  }
  static auto ambiguous(ambiguity_reason reason) -> parse_result {
    return parse_result{ambiguous_t{reason}};
  }
};
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- MECHANISM
-- ═══════════════════════════════════════════════════════════════════════════════

def genMechanism : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// Security mechanisms
// Generated from: Foundry.Cornell.Zmtp.Mechanism
// ═══════════════════════════════════════════════════════════════════════════════

// Lean: inductive Mechanism where
//   | null   : Mechanism
//   | plain  : Mechanism
//   | curve  : Mechanism
enum class mechanism : std::uint8_t {
  null_,  // underscore to avoid C++ keyword
  plain,
  curve,
};

// Lean: def parseMechanism (bytes : Bytes) : Option Mechanism
[[nodiscard]] inline auto parse_mechanism(std::span<const std::byte> bytes) noexcept
    -> std::optional<mechanism> {
  if (bytes.size() < mechanism_size) {
    return std::nullopt;
  }

  auto const* data = reinterpret_cast<const char*>(bytes.data());

  // Lean: if bytes[0..4] == \"NULL\" && bytes[4] == 0 then some .null
  if (std::memcmp(data, \"NULL\", 4) == 0 && data[4] == '\\0') {
    return mechanism::null_;
  }
  // Lean: if bytes[0..5] == \"PLAIN\" && bytes[5] == 0 then some .plain
  if (std::memcmp(data, \"PLAIN\", 5) == 0 && data[5] == '\\0') {
    return mechanism::plain;
  }
  // Lean: if bytes[0..5] == \"CURVE\" && bytes[5] == 0 then some .curve
  if (std::memcmp(data, \"CURVE\", 5) == 0 && data[5] == '\\0') {
    return mechanism::curve;
  }

  return std::nullopt;
}
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- GREETING
-- ═══════════════════════════════════════════════════════════════════════════════

def genGreeting : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// Greeting
// Generated from: Foundry.Cornell.Zmtp.Greeting, Foundry.Cornell.Zmtp.parseGreeting
//
// Proven properties:
//   - greeting_exactly_64: consumes exactly 64 bytes on success
//   - parseGreeting_deterministic: same bytes → same result
// ═══════════════════════════════════════════════════════════════════════════════

// Lean: structure Greeting where
//   versionMajor : UInt8
//   versionMinor : UInt8
//   mechanism    : Mechanism
//   asServer     : Bool
struct greeting {
  std::uint8_t version_major;
  std::uint8_t version_minor;
  mechanism mech;
  bool as_server;
};

// Lean: def parseGreeting (bytes : Bytes) : StrictParseResult Greeting
[[nodiscard]] inline auto parse_greeting(std::span<const std::byte> bytes) noexcept
    -> parse_result<greeting> {
  // Lean: if bytes.size < greetingSize then .incomplete (greetingSize - bytes.size)
  if (bytes.size() < greeting_size) {
    return parse_result<greeting>::incomplete(greeting_size - bytes.size());
  }

  auto const sig0 = static_cast<std::uint8_t>(bytes[0]);
  auto const sig9 = static_cast<std::uint8_t>(bytes[9]);

  // Lean: if sig0 != signatureByte0 || sig9 != signatureByte9 then .ambiguous (.invalidSignature sig0 sig9)
  if (sig0 != signature_byte_0 || sig9 != signature_byte_9) {
    return parse_result<greeting>::ambiguous(ambiguity_reason::invalid_signature);
  }

  auto const major = static_cast<std::uint8_t>(bytes[10]);
  auto const minor = static_cast<std::uint8_t>(bytes[11]);

  // Lean: if major < 3 then .ambiguous (.unsupportedVersion major minor)
  if (major < 3) {
    return parse_result<greeting>::ambiguous(ambiguity_reason::unsupported_version);
  }

  auto const mech_bytes = bytes.subspan(12, mechanism_size);
  auto const mech = parse_mechanism(mech_bytes);

  // Lean: match parseMechanism mechBytes with | none => .ambiguous (.mechanismMismatch ...)
  if (!mech) {
    return parse_result<greeting>::ambiguous(ambiguity_reason::mechanism_mismatch);
  }

  // Lean: let asServer := bytes[32]! != 0
  auto const as_server = static_cast<std::uint8_t>(bytes[32]) != 0;

  // Lean: .ok ⟨major, minor, mech, asServer⟩ rest
  return parse_result<greeting>::ok(greeting{major, minor, *mech, as_server}, greeting_size);
}
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- FRAME HEADER
-- ═══════════════════════════════════════════════════════════════════════════════

def genFrameHeader : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// Frame header
// Generated from: Foundry.Cornell.Zmtp.FrameHeader, Foundry.Cornell.Zmtp.parseFrameHeader
//
// Proven properties:
//   - flags_unambiguous: with enough bytes, parsing is never incomplete
//   - parseFrameHeader_deterministic: same bytes → same result
// ═══════════════════════════════════════════════════════════════════════════════

// Lean: structure FrameHeader where
//   size      : Nat
//   hasMore   : Bool
//   isLong    : Bool
//   isCommand : Bool
struct frame_header {
  std::uint64_t size;
  bool has_more;
  bool is_long;
  bool is_command;
};

// Lean: def hasReservedBits (flags : UInt8) : Bool := (flags &&& flagReservedMask) != 0
[[nodiscard]] inline auto has_reserved_bits(std::uint8_t flags) noexcept -> bool {
  return (flags & flag_reserved_mask) != 0;
}

// Lean: def readSize64BE (bytes : Bytes) (offset : Nat) : UInt64
[[nodiscard]] inline auto read_size_64_be(std::span<const std::byte> bytes) noexcept
    -> std::uint64_t {
  std::uint64_t result = 0;
  for (int i = 0; i < 8; ++i) {
    result = (result << 8) | static_cast<std::uint8_t>(bytes[i]);
  }
  return result;
}

// Lean: def parseFrameHeader (bytes : Bytes) : StrictParseResult FrameHeader
[[nodiscard]] inline auto parse_frame_header(std::span<const std::byte> bytes) noexcept
    -> parse_result<frame_header> {
  // Lean: if bytes.size < 1 then .incomplete 1
  if (bytes.empty()) {
    return parse_result<frame_header>::incomplete(1);
  }

  auto const flags = static_cast<std::uint8_t>(bytes[0]);

  // Lean: if hasReservedBits flags then .ambiguous (.reservedFlagsSet flags)
  if (has_reserved_bits(flags)) {
    return parse_result<frame_header>::ambiguous(ambiguity_reason::reserved_flags_set);
  }

  // Lean: let (hasMore, isLong, isCommand) := parseFlags flags
  bool const has_more = (flags & flag_more) != 0;
  bool const is_long = (flags & flag_long) != 0;
  bool const is_command = (flags & flag_command) != 0;

  if (is_long) {
    // Lean: if bytes.size < 9 then .incomplete (9 - bytes.size)
    if (bytes.size() < 9) {
      return parse_result<frame_header>::incomplete(9 - bytes.size());
    }
    auto const size = read_size_64_be(bytes.subspan(1, 8));
    // Lean: if size64 > maxFrameSize.toUInt64 then .ambiguous (.frameTooLarge size64)
    if (size > max_frame_size) {
      return parse_result<frame_header>::ambiguous(ambiguity_reason::frame_too_large);
    }
    return parse_result<frame_header>::ok(frame_header{size, has_more, true, is_command}, 9);
  } else {
    // Lean: if bytes.size < 2 then .incomplete (2 - bytes.size)
    if (bytes.size() < 2) {
      return parse_result<frame_header>::incomplete(2 - bytes.size());
    }
    auto const size = static_cast<std::uint64_t>(static_cast<std::uint8_t>(bytes[1]));
    return parse_result<frame_header>::ok(frame_header{size, has_more, false, is_command}, 2);
  }
}
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- FRAME
-- ═══════════════════════════════════════════════════════════════════════════════

def genFrame : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// Frame
// Generated from: Foundry.Cornell.Zmtp.Frame, Foundry.Cornell.Zmtp.parseFrameBody
// ═══════════════════════════════════════════════════════════════════════════════

// Lean: structure Frame where
//   header : FrameHeader
//   body   : Bytes
struct frame {
  frame_header header;
  std::vector<std::byte> body;
};

// Parse complete frame (header + body)
[[nodiscard]] inline auto parse_frame(std::span<const std::byte> bytes) noexcept
    -> parse_result<frame> {
  auto header_result = parse_frame_header(bytes);

  if (header_result.is_incomplete()) {
    return parse_result<frame>::incomplete(header_result.get_incomplete().needed);
  }
  if (header_result.is_ambiguous()) {
    return parse_result<frame>::ambiguous(header_result.get_ambiguous().reason);
  }

  auto const& [header, header_consumed] = header_result.get_ok();
  auto const remaining = bytes.subspan(header_consumed);

  // Lean: if bytes.size < header.size then .incomplete (header.size - bytes.size)
  if (remaining.size() < header.size) {
    return parse_result<frame>::incomplete(header.size - remaining.size());
  }

  std::vector<std::byte> body(remaining.begin(), remaining.begin() + header.size);
  return parse_result<frame>::ok(frame{header, std::move(body)}, header_consumed + header.size);
}
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- COMMANDS
-- ═══════════════════════════════════════════════════════════════════════════════

def genCommands : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// Commands
// Generated from: Foundry.Cornell.Zmtp.Command, Foundry.Cornell.Zmtp.parseCommand
// ═══════════════════════════════════════════════════════════════════════════════

// Lean: inductive Command where
//   | ready     : List (String × Bytes) → Command
//   | error     : String → Command
//   | subscribe : Bytes → Command
//   | cancel    : Bytes → Command
//   | ping      : Bytes → Command
//   | pong      : Bytes → Command
//   | unknown   : String → Bytes → Command
enum class command_type : std::uint8_t {
  ready,
  error,
  subscribe,
  cancel,
  ping,
  pong,
  unknown,
};

struct command {
  command_type type;
  std::string name;
  std::vector<std::byte> data;
};

// Lean: def isPrintableAscii (b : UInt8) : Bool := b >= 0x20 && b <= 0x7E
[[nodiscard]] inline auto is_printable_ascii(std::byte b) noexcept -> bool {
  auto const v = static_cast<std::uint8_t>(b);
  return v >= 0x20 && v <= 0x7E;
}

// Lean: def parseCommand (body : Bytes) : StrictParseResult Command
[[nodiscard]] inline auto parse_command(std::span<const std::byte> body) noexcept
    -> parse_result<command> {
  // Lean: if body.size < 1 then .ambiguous .invalidCommandName
  if (body.empty()) {
    return parse_result<command>::ambiguous(ambiguity_reason::invalid_command_name);
  }

  auto const name_len = static_cast<std::size_t>(static_cast<std::uint8_t>(body[0]));

  // Lean: if nameLen == 0 || nameLen > 255 then .ambiguous .invalidCommandName
  if (name_len == 0 || name_len > 255) {
    return parse_result<command>::ambiguous(ambiguity_reason::invalid_command_name);
  }

  if (body.size() < 1 + name_len) {
    return parse_result<command>::incomplete(1 + name_len - body.size());
  }

  auto const name_bytes = body.subspan(1, name_len);

  // Lean: if !allPrintableAscii nameBytes then .ambiguous .invalidCommandName
  for (auto const b : name_bytes) {
    if (!is_printable_ascii(b)) {
      return parse_result<command>::ambiguous(ambiguity_reason::invalid_command_name);
    }
  }

  std::string name(reinterpret_cast<const char*>(name_bytes.data()), name_len);
  auto const data_bytes = body.subspan(1 + name_len);
  std::vector<std::byte> data(data_bytes.begin(), data_bytes.end());

  // Lean: dispatch on known commands
  command_type type = command_type::unknown;
  if (name == \"READY\")
    type = command_type::ready;
  else if (name == \"ERROR\")
    type = command_type::error;
  else if (name == \"SUBSCRIBE\")
    type = command_type::subscribe;
  else if (name == \"CANCEL\")
    type = command_type::cancel;
  else if (name == \"PING\")
    type = command_type::ping;
  else if (name == \"PONG\")
    type = command_type::pong;

  return parse_result<command>::ok(command{type, std::move(name), std::move(data)},
                                   body.size());
}
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- CONNECTION STATE
-- ═══════════════════════════════════════════════════════════════════════════════

def genConnState : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// Connection state
// Generated from: Foundry.Cornell.Zmtp.ConnState
//
// Proven properties:
//   - reset_is_initial: reset always returns to initial state
// ═══════════════════════════════════════════════════════════════════════════════

// Lean: inductive ConnState where
//   | awaitGreeting  : ConnState
//   | awaitHandshake : Greeting → ConnState
//   | ready          : Greeting → ConnState
//   | failed         : AmbiguityReason → ConnState
enum class conn_phase : std::uint8_t {
  await_greeting,
  await_handshake,
  ready,
  failed,
};

struct zmtp_state {
  conn_phase phase = conn_phase::await_greeting;
  std::optional<greeting> peer_greeting;
  std::optional<ambiguity_reason> failure_reason;
  std::vector<std::byte> buffer;

  [[nodiscard]] auto is_failed() const noexcept -> bool { return phase == conn_phase::failed; }
  [[nodiscard]] auto is_ready() const noexcept -> bool { return phase == conn_phase::ready; }
};
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- MACHINE INSTANCE
-- ═══════════════════════════════════════════════════════════════════════════════

def genMachineInstance : String :=
"// ═══════════════════════════════════════════════════════════════════════════════
// ZMTP Machine
// ═══════════════════════════════════════════════════════════════════════════════

/// ZMTP protocol machine implementing the evring::machine concept
struct zmtp_machine {
  using state_type = zmtp_state;

  bool as_server = false;

  explicit zmtp_machine(bool server = false) : as_server(server) {}

  [[nodiscard]] auto initial() const -> state_type { return zmtp_state{}; }

  [[nodiscard]] auto step(state_type state, event const& ev) const
      -> step_result<state_type> {
    // Append received data to buffer
    if (!ev.data.empty()) {
      state.buffer.insert(state.buffer.end(), ev.data.begin(), ev.data.end());
    }

    std::vector<operation> ops;

    switch (state.phase) {
    case conn_phase::await_greeting: {
      auto result = parse_greeting(state.buffer);

      if (result.is_incomplete()) {
        return {std::move(state), {}};
      }

      if (result.is_ambiguous()) {
        state.phase = conn_phase::failed;
        state.failure_reason = result.get_ambiguous().reason;
        return {std::move(state), {}};
      }

      auto const& [greet, consumed] = result.get_ok();
      state.peer_greeting = greet;
      state.buffer.erase(state.buffer.begin(), state.buffer.begin() + consumed);
      state.phase = conn_phase::await_handshake;

      return {std::move(state), std::move(ops)};
    }

    case conn_phase::await_handshake: {
      auto result = parse_frame(state.buffer);

      if (result.is_incomplete()) {
        return {std::move(state), {}};
      }

      if (result.is_ambiguous()) {
        state.phase = conn_phase::failed;
        state.failure_reason = result.get_ambiguous().reason;
        return {std::move(state), {}};
      }

      auto const& [frm, consumed] = result.get_ok();

      if (!frm.header.is_command) {
        state.phase = conn_phase::failed;
        state.failure_reason = ambiguity_reason::unexpected_command;
        return {std::move(state), {}};
      }

      auto cmd_result = parse_command(frm.body);

      if (cmd_result.is_ambiguous()) {
        state.phase = conn_phase::failed;
        state.failure_reason = cmd_result.get_ambiguous().reason;
        return {std::move(state), {}};
      }

      if (cmd_result.is_ok()) {
        auto const& cmd = cmd_result.get_ok().value;
        if (cmd.type == command_type::ready) {
          state.buffer.erase(state.buffer.begin(), state.buffer.begin() + consumed);
          state.phase = conn_phase::ready;
          return {std::move(state), std::move(ops)};
        } else {
          state.phase = conn_phase::failed;
          state.failure_reason = ambiguity_reason::unexpected_command;
          return {std::move(state), {}};
        }
      }

      return {std::move(state), {}};
    }

    case conn_phase::ready: {
      auto result = parse_frame(state.buffer);

      if (result.is_incomplete()) {
        return {std::move(state), {}};
      }

      if (result.is_ambiguous()) {
        state.phase = conn_phase::failed;
        state.failure_reason = result.get_ambiguous().reason;
        return {std::move(state), {}};
      }

      auto const& [frm, consumed] = result.get_ok();
      state.buffer.erase(state.buffer.begin(), state.buffer.begin() + consumed);

      return {std::move(state), std::move(ops)};
    }

    case conn_phase::failed:
      return {std::move(state), {}};
    }

    return {std::move(state), {}};
  }

  [[nodiscard]] auto done(state_type const& state) const -> bool { return state.is_failed(); }
};

// Verify it satisfies the machine concept
static_assert(machine<zmtp_machine>);
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- FOOTER
-- ═══════════════════════════════════════════════════════════════════════════════

def genFooter : String :=
"
} // namespace evring::zmtp
"

-- ═══════════════════════════════════════════════════════════════════════════════
-- COMPLETE FILE GENERATION
-- ═══════════════════════════════════════════════════════════════════════════════

def genZmtpH : String :=
  genHeader ++ "\n" ++
  genConstants ++ "\n" ++
  genAmbiguityReason ++ "\n" ++
  genParseResult ++ "\n" ++
  genMechanism ++ "\n" ++
  genGreeting ++ "\n" ++
  genFrameHeader ++ "\n" ++
  genFrame ++ "\n" ++
  genCommands ++ "\n" ++
  genConnState ++ "\n" ++
  genMachineInstance ++ "\n" ++
  genFooter

#eval IO.println genZmtpH

end Cornell.ExtractZmtp

-- Main entry point
def main : IO Unit := do
  IO.println Cornell.ExtractZmtp.genZmtpH
