{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE BangPatterns #-}

-- ═══════════════════════════════════════════════════════════════════════════════
-- GENERATED BY CORNELL - DO NOT EDIT
-- Source: Cornell.ExtractHaskell (from Cornell.Sigil specification)
--
-- This file is extracted from the verified Lean specification.
-- The state machine and reset-on-ambiguity behavior are proven correct in Lean.
--
-- To regenerate:
--   lake build && lake exe cornell_haskell_gen > path/to/Sigil.hs
-- ═══════════════════════════════════════════════════════════════════════════════

-- | SIGIL wire format decoder as a Machine instance.
--
-- SIGIL is the attestation layer for AI infrastructure - typed contracts
-- for tokenizers, tool formats, and streaming state machines.
--
-- = Wire Format Overview
--
-- @
-- Byte encoding:
--   0xxxxxxx  = hot token (ID in lower 7 bits, 0x00-0x7E)
--   10xxxxxx  = extended token (varint follows)
--   1100xxxx  = stream control (0xC0-0xCF)
--   1101xxxx  = reserved
--   1110xxxx  = extension
--   1111xxxx  = envelope (connection setup, rare)
-- @
--
-- = Reset-on-Ambiguity
--
-- The decoder implements reset-on-ambiguity discipline:
--
-- - Mode end without matching start → reset
-- - Nested mode start (e.g., TOOL_CALL_START while in THINK) → reset
-- - Reserved opcode → reset
-- - Varint overflow → reset
--
-- On ambiguity, the decoder emits an 'AmbiguityReset' chunk and
-- returns to 'initSigilState' (the unique ground state).
module Foundry.Core.Evring.Sigil
  ( -- * Machine
    SigilMachine(..)
    -- * State
  , SigilState(..)
  , ParseMode(..)
  , initSigilState
  , resetSigilState
    -- * Decoded chunks
  , Chunk(..)
  , ChunkContent(..)
    -- * Ambiguity handling
  , AmbiguityReason(..)
    -- * Parse results
  , SigilParseResult(..)
    -- * Token types
  , TokenId
    -- * Byte classification
  , isHotByte
  , isExtendedByte
  , isControlByte
    -- * Varint decoding
  , decodeVarint
  ) where

import Data.Bits ((.&.), (.|.), shiftL)
import Data.ByteString (ByteString)
import qualified Data.ByteString as BS
import Data.Word (Word8, Word32)
import GHC.Generics (Generic)

import Foundry.Core.Evring.Machine
  ( Machine(State, initial, step, done)
  , StepResult(StepResult)
  )
import Foundry.Core.Evring.Event (Event(eventData))

-- ═══════════════════════════════════════════════════════════════════════════════
-- CONSTANTS
-- Generated from: Cornell.Sigil.Opcode
-- ═══════════════════════════════════════════════════════════════════════════════

-- | Control opcodes (0xC0-0xCF)
-- Prefixed with underscore to avoid -Wunused-top-binds with -Werror
_opChunkEnd, _opToolCallStart, _opToolCallEnd :: Word8
_opThinkStart, _opThinkEnd, _opCodeBlockStart, _opCodeBlockEnd :: Word8
_opFlush, _opStreamEnd :: Word8

_opChunkEnd       = 0xC0
_opToolCallStart  = 0xC1
_opToolCallEnd    = 0xC2
_opThinkStart     = 0xC3
_opThinkEnd       = 0xC4
_opCodeBlockStart = 0xC5
_opCodeBlockEnd   = 0xC6
_opFlush          = 0xC7
-- 0xC8-0xCE reserved
_opStreamEnd      = 0xCF

-- | Reserved hot token byte
_hotTokenReserved :: Word8
_hotTokenReserved = 0x7F

-- ═══════════════════════════════════════════════════════════════════════════════
-- TOKEN TYPES
-- Generated from: Cornell.Sigil.TokenId
-- ═══════════════════════════════════════════════════════════════════════════════

-- | Token ID in the model's vocabulary (typically 0-150k)
type TokenId = Word32

-- ═══════════════════════════════════════════════════════════════════════════════
-- BYTE CLASSIFICATION
-- Generated from: Cornell.Sigil.isHotByte, isExtendedByte, isControlByte
-- ═══════════════════════════════════════════════════════════════════════════════

-- | Is this byte a hot token? (high bit clear, not 0x7F)
-- Lean: def isHotByte (b : UInt8) : Bool := b < 0x7F
isHotByte :: Word8 -> Bool
isHotByte byte = byte .&. 0x80 == 0 && byte /= 0x7F
{-# INLINE isHotByte #-}

-- | Is this byte an extended token escape? (0x80-0xBF)
-- Lean: def isExtendedByte (b : UInt8) : Bool := b >= 0x80 && b < 0xC0
isExtendedByte :: Word8 -> Bool
isExtendedByte byte = byte .&. 0xC0 == 0x80
{-# INLINE isExtendedByte #-}

-- | Is this byte a control opcode? (0xC0-0xCF or 0xF0)
-- Lean: def isControlByte (b : UInt8) : Bool := b >= 0xC0 && b < 0xD0
isControlByte :: Word8 -> Bool
isControlByte byte = (byte .&. 0xF0 == 0xC0) || (byte == 0xF0)
{-# INLINE isControlByte #-}

-- | Is this a reserved control opcode? (0xC8-0xCE)
-- Prefixed with underscore to avoid -Wunused-top-binds with -Werror
_isReservedControl :: Word8 -> Bool
_isReservedControl byte = byte >= 0xC8 && byte <= 0xCE
{-# INLINE _isReservedControl #-}

-- ═══════════════════════════════════════════════════════════════════════════════
-- PARSE MODE
-- Generated from: Cornell.Sigil.ParseMode
-- ═══════════════════════════════════════════════════════════════════════════════

-- | Parser mode for semantic blocks.
data ParseMode
  = ModeText       -- ^ Lean: | text
  | ModeThink      -- ^ Lean: | think
  | ModeToolCall   -- ^ Lean: | toolCall
  | ModeCodeBlock  -- ^ Lean: | codeBlock
  deriving stock (Eq, Show, Generic)

-- ═══════════════════════════════════════════════════════════════════════════════
-- AMBIGUITY REASONS
-- Generated from: Cornell.Sigil.AmbiguityReason
-- ═══════════════════════════════════════════════════════════════════════════════

-- | Reasons for ambiguity-triggered reset.
--
-- These are hard ambiguities where guessing would be worse than resetting.
data AmbiguityReason
  = UnmatchedModeEnd !ParseMode
    -- ^ Lean: | unmatchedModeEnd : ParseMode → AmbiguityReason
  | NestedModeStart !ParseMode !ParseMode
    -- ^ Lean: | nestedModeStart : ParseMode → ParseMode → AmbiguityReason
  | ReservedOpcode !Word8
    -- ^ Lean: | reservedOpcode : UInt8 → AmbiguityReason
  | VarintOverflow
    -- ^ Lean: | varintOverflow : AmbiguityReason
  | UpstreamError !ByteString
    -- ^ Lean: | upstreamError : String → AmbiguityReason
  deriving stock (Eq, Show, Generic)

-- ═══════════════════════════════════════════════════════════════════════════════
-- PARSE RESULT
-- Generated from: Cornell.Sigil.StrictParseResult
-- ═══════════════════════════════════════════════════════════════════════════════

-- | Strict parse result with three outcomes.
data SigilParseResult a
  = Ok !a !ByteString        -- ^ Success with remaining bytes
  | Incomplete               -- ^ Need more bytes (streaming)
  | Ambiguous !AmbiguityReason  -- ^ Protocol violation, must reset
  deriving stock (Eq, Show, Generic)

instance Functor SigilParseResult where
  fmap f = \case
    Ok a rest -> Ok (f a) rest
    Incomplete -> Incomplete
    Ambiguous r -> Ambiguous r

-- ═══════════════════════════════════════════════════════════════════════════════
-- CHUNK TYPES
-- Generated from: Cornell.Sigil.ChunkContent, Cornell.Sigil.Chunk
-- ═══════════════════════════════════════════════════════════════════════════════

-- | A decoded semantic chunk.
data Chunk = Chunk
  { chunkContent  :: !ChunkContent
  , chunkComplete :: !Bool
    -- ^ True if ends on semantic boundary
  } deriving stock (Eq, Show, Generic)

-- | Content types.
data ChunkContent
  = TextContent ![TokenId]
    -- ^ Regular text tokens
  | ThinkContent ![TokenId]
    -- ^ Thinking block (may be hidden)
  | ToolCallContent ![TokenId]
    -- ^ Tool call (parse as JSON)
  | CodeBlockContent ![TokenId]
    -- ^ Code block
  | StreamEnd
    -- ^ End of stream
  | DecodeError !ByteString
    -- ^ Something went wrong
  | AmbiguityReset !AmbiguityReason
    -- ^ Ambiguity detected, state reset to ground
  deriving stock (Eq, Show, Generic)

-- ═══════════════════════════════════════════════════════════════════════════════
-- VARINT DECODING
-- Generated from: Cornell.Sigil.parseVarint
-- ═══════════════════════════════════════════════════════════════════════════════

-- | Decode LEB128 varint from ByteString.
-- Returns (value, bytes consumed) or Nothing if incomplete/overflow.
-- Lean: def parseVarint (bs : Bytes) : StrictParseResult (UInt32 × Nat)
decodeVarint :: ByteString -> Maybe (Word32, Int)
decodeVarint bs = go 0 0 0
  where
    go :: Word32 -> Int -> Int -> Maybe (Word32, Int)
    go !acc !shift !offset
      | offset >= BS.length bs = Nothing  -- Incomplete
      | otherwise =
          let byte = BS.index bs offset
              newAcc = acc .|. (fromIntegral (byte .&. 0x7F) `shiftL` shift)
          in if byte .&. 0x80 == 0
             then Just (newAcc, offset + 1)
             else if shift >= 28
                  then Nothing  -- Overflow protection for Word32
                  else go newAcc (shift + 7) (offset + 1)
{-# INLINE decodeVarint #-}

-- ═══════════════════════════════════════════════════════════════════════════════
-- DECODE STATE
-- Generated from: Cornell.Sigil.DecodeState
-- ═══════════════════════════════════════════════════════════════════════════════

-- | Incremental decoder state.
data SigilState = SigilState
  { sigilParseMode :: !ParseMode       -- ^ Lean: parseMode : ParseMode
  , sigilBuffer    :: ![TokenId]       -- ^ Lean: buffer : List TokenId (reversed for efficiency)
  , sigilLeftover  :: !ByteString      -- ^ Lean: leftover : Bytes
  , sigilChunks    :: ![Chunk]         -- ^ Accumulated chunks (reversed)
  , sigilDone      :: !Bool            -- ^ True if stream ended
  } deriving stock (Eq, Show, Generic)

-- | Initial decode state (the unique ground state).
--
-- This is the only valid starting point and the state we return to
-- after any ambiguity.
--
-- Lean: def initDecodeState : DecodeState := { parseMode := .text, buffer := [], leftover := ByteArray.empty }
--
-- Proven properties (from Cornell.Sigil):
--   - reset_is_ground: ∀ s, resetDecodeState s = initDecodeState
--   - no_leakage: ∀ s₁ s₂, resetDecodeState s₁ = resetDecodeState s₂
--   - reset_idempotent: ∀ s, resetDecodeState (resetDecodeState s) = resetDecodeState s
initSigilState :: SigilState
initSigilState = SigilState ModeText [] BS.empty [] False

-- | Reset to ground state, discarding any accumulated context.
--
-- Called on ambiguity. Returns to 'initSigilState' unconditionally.
-- Lean: def resetDecodeState (_s : DecodeState) : DecodeState := initDecodeState
resetSigilState :: SigilState -> SigilState
resetSigilState _ = initSigilState

-- ═══════════════════════════════════════════════════════════════════════════════
-- CHUNK BUILDING
-- Generated from: Cornell.Sigil.buildChunk
-- ═══════════════════════════════════════════════════════════════════════════════

-- | Create chunk from current state.
buildChunk :: SigilState -> Bool -> Chunk
buildChunk state complete = Chunk content complete
  where
    tokens = reverse (sigilBuffer state)
    content = case sigilParseMode state of
      ModeText      -> TextContent tokens
      ModeThink     -> ThinkContent tokens
      ModeToolCall  -> ToolCallContent tokens
      ModeCodeBlock -> CodeBlockContent tokens

-- ═══════════════════════════════════════════════════════════════════════════════
-- CONTROL BYTE HANDLING
-- Generated from: Cornell.Sigil.handleControl
--
-- This is where ambiguity detection happens. The Lean proofs guarantee:
--   - handleControl_reserved_resets: reserved opcodes always reset
--   - handleControl_toolCallStart_think_resets: nested starts reset
--   - handleControl_toolCallEnd_text_resets: unmatched ends reset
--   - handleControl_ambiguity_is_ground: all resets produce initSigilState
-- ═══════════════════════════════════════════════════════════════════════════════

-- | Handle control opcodes.
--
-- This is where ambiguity detection happens. Invalid mode transitions
-- trigger reset-on-ambiguity.
handleControlByte ::
  SigilState ->
  Word8 ->
  ByteString ->
  Either ByteString (SigilState, Maybe Chunk, ByteString)
handleControlByte state opcode rest = Right $ case opcode of
  -- Lean: | .chunkEnd => ...
  0xC0 ->
    let chunk = buildChunk state True
        newState = state { sigilBuffer = [] }
    in (newState, Just chunk, rest)

  -- Lean: | .toolCallStart => match state.parseMode with | .text => ... | mode => AMBIGUITY
  0xC1 ->
    case sigilParseMode state of
      ModeText ->
        let pendingChunk = if null (sigilBuffer state)
                           then Nothing
                           else Just (buildChunk state False)
            newState = state { sigilParseMode = ModeToolCall
                             , sigilBuffer = []
                             , sigilLeftover = BS.empty }
        in (newState, pendingChunk, rest)
      currentMode ->
        -- AMBIGUITY: nested mode start
        let chunk = Chunk (AmbiguityReset (NestedModeStart currentMode ModeToolCall)) True
        in (initSigilState, Just chunk, rest)

  -- Lean: | .toolCallEnd => match state.parseMode with | .toolCall => ... | mode => AMBIGUITY
  0xC2 ->
    case sigilParseMode state of
      ModeToolCall ->
        let chunk = buildChunk state True
            newState = state { sigilParseMode = ModeText
                             , sigilBuffer = []
                             , sigilLeftover = BS.empty }
        in (newState, Just chunk, rest)
      currentMode ->
        -- AMBIGUITY: end without matching start
        let chunk = Chunk (AmbiguityReset (UnmatchedModeEnd currentMode)) True
        in (initSigilState, Just chunk, rest)

  0xC3 ->
    case sigilParseMode state of
      ModeText ->
        let pendingChunk = if null (sigilBuffer state)
                           then Nothing
                           else Just (buildChunk state False)
            newState = state { sigilParseMode = ModeThink
                             , sigilBuffer = []
                             , sigilLeftover = BS.empty }
        in (newState, pendingChunk, rest)
      currentMode ->
        let chunk = Chunk (AmbiguityReset (NestedModeStart currentMode ModeThink)) True
        in (initSigilState, Just chunk, rest)

  0xC4 ->
    case sigilParseMode state of
      ModeThink ->
        let chunk = buildChunk state True
            newState = state { sigilParseMode = ModeText
                             , sigilBuffer = []
                             , sigilLeftover = BS.empty }
        in (newState, Just chunk, rest)
      currentMode ->
        let chunk = Chunk (AmbiguityReset (UnmatchedModeEnd currentMode)) True
        in (initSigilState, Just chunk, rest)

  0xC5 ->
    case sigilParseMode state of
      ModeText ->
        let pendingChunk = if null (sigilBuffer state)
                           then Nothing
                           else Just (buildChunk state False)
            newState = state { sigilParseMode = ModeCodeBlock
                             , sigilBuffer = []
                             , sigilLeftover = BS.empty }
        in (newState, pendingChunk, rest)
      currentMode ->
        let chunk = Chunk (AmbiguityReset (NestedModeStart currentMode ModeCodeBlock)) True
        in (initSigilState, Just chunk, rest)

  0xC6 ->
    case sigilParseMode state of
      ModeCodeBlock ->
        let chunk = buildChunk state True
            newState = state { sigilParseMode = ModeText
                             , sigilBuffer = []
                             , sigilLeftover = BS.empty }
        in (newState, Just chunk, rest)
      currentMode ->
        let chunk = Chunk (AmbiguityReset (UnmatchedModeEnd currentMode)) True
        in (initSigilState, Just chunk, rest)

  -- Lean: | .flush => ...
  0xC7 ->
    let chunk = buildChunk state False
        newState = state { sigilBuffer = [] }
    in (newState, Just chunk, rest)

  -- Lean: | .streamEnd => ...
  0xCF ->
    let chunk = if null (sigilBuffer state)
                then Chunk StreamEnd True
                else buildChunk state True
        newState = initSigilState { sigilDone = True }
    in (newState, Just chunk, rest)

  _ | opcode >= 0xC8 && opcode <= 0xCE ->
    -- Lean: | .reserved code => AMBIGUITY
    let chunk = Chunk (AmbiguityReset (ReservedOpcode opcode)) True
    in (initSigilState, Just chunk, rest)

  _ ->
    -- Unknown control outside reserved range, ignore
    (state, Nothing, rest)

-- ═══════════════════════════════════════════════════════════════════════════════
-- BYTE PROCESSING
-- Generated from: Cornell.Sigil.decodeByte
-- ═══════════════════════════════════════════════════════════════════════════════

-- | Decode a single byte, possibly consuming more for varint.
decodeSingleByte ::
  SigilState ->
  Word8 ->
  ByteString ->
  Either ByteString (SigilState, Maybe Chunk, ByteString)
decodeSingleByte state byte rest
  -- Lean: if isHotByte b then ...
  | isHotByte byte =
      let tokenId = fromIntegral byte
          newState = state { sigilBuffer = tokenId : sigilBuffer state }
      in Right (newState, Nothing, rest)
  -- Extended token (0x80-0xBF)
  | isExtendedByte byte =
      case decodeVarint rest of
        Nothing -> Left (BS.cons byte rest)  -- Incomplete varint
        Just (tokenId, consumed) ->
          let newState = state { sigilBuffer = tokenId : sigilBuffer state }
          in Right (newState, Nothing, BS.drop consumed rest)
  -- Lean: else if isControlByte b then ...
  | isControlByte byte =
      handleControlByte state byte rest
  -- Reserved/unknown - ignore
  | otherwise =
      Right (state, Nothing, rest)

-- | Process all bytes in the buffer.
processBytes ::
  SigilState ->
  ByteString ->
  [Chunk] ->
  (SigilState, [Chunk])
processBytes !state !input !acc
  | BS.null input = (state { sigilLeftover = BS.empty }, reverse acc)
  | otherwise =
      let byte = BS.head input
          rest = BS.tail input
      in case decodeSingleByte state byte rest of
        Left leftover ->
          (state { sigilLeftover = leftover }, reverse acc)
        Right (newState, maybeChunk, remaining) ->
          let newAcc = maybe acc (: acc) maybeChunk
          in processBytes newState remaining newAcc

-- ═══════════════════════════════════════════════════════════════════════════════
-- MACHINE INSTANCE
-- ═══════════════════════════════════════════════════════════════════════════════

-- | SIGIL decoder machine.
data SigilMachine = SigilMachine
  deriving stock (Eq, Show, Generic)

instance Machine SigilMachine where
  type State SigilMachine = SigilState

  initial _ = initSigilState

  step _machine state event =
    -- Append any received data to buffer
    let inputBytes = sigilLeftover state <> eventData event
        (newState, chunks) = processBytes state inputBytes []
        -- Store chunks in state for retrieval
        finalState = newState { sigilChunks = chunks ++ sigilChunks newState }
    in StepResult finalState []

  done _ state = sigilDone state

-- ═══════════════════════════════════════════════════════════════════════════════
-- VERIFICATION NOTES
-- ═══════════════════════════════════════════════════════════════════════════════

{- |
== Verified Properties (from Cornell.Sigil)

The Lean formalization proves:

1. @reset_is_ground@: Reset always produces initSigilState
2. @ground_unique@: All resets produce the same state
3. @reset_idempotent@: reset(reset(s)) = reset(s)
4. @no_leakage@: Different states reset to identical states
5. @reset_erases_mode@: Mode is text after reset
6. @reset_erases_buffer@: Buffer is empty after reset
7. @handleControl_reserved_resets@: Reserved opcodes reset to init
8. @handleControl_nested_start_resets@: Nested mode starts reset
9. @handleControl_unmatched_end_resets@: Unmatched mode ends reset

This Haskell implementation is generated from the Lean specification exactly.
-}

